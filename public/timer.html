<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fasting Timer - Your Journey</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #fcd34d 0%, #fb923c 50%, #ec4899 100%);
            min-height: 100vh;
            padding-bottom: 85px;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 480px;
            margin: 0 auto;
            padding: 20px;
            width: 100%;
        }
        
        .timer-card {
            background: white;
            border-radius: 20px;
            padding: 25px 30px 30px 30px;
            margin: 20px 0;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            text-align: center;
            min-height: 600px;
            max-height: none;
            display: flex;
            flex-direction: column;
            overflow: visible;
            transition: min-height 0.3s ease;
            justify-content: flex-start;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #28a745;
            display: inline-block;
            margin-right: 8px;
        }
        
        .status-indicator.fasting {
            background: #fb923c;
        }
        
        .status-indicator.feeding {
            background: #28a745;
        }
        
        .status-text {
            font-size: 1.1rem;
            font-weight: 600;
            color: #666;
            margin: 30px 0 20px 0;
        }
        
        .circular-timer {
            width: min(280px, 70vw);
            height: min(280px, 70vw);
            margin: 30px auto 20px;
            position: relative;
            border-radius: 50%;
            background: #f0f0f0;
            box-shadow: 
                inset 8px 8px 16px rgba(163, 177, 198, 0.6),
                inset -8px -8px 16px rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: visible; /* Allow pulse to expand beyond container */
        }
        
        .timer-progress-outer {
            position: absolute;
            top: 50%;
            left: 50%;
            width: calc(min(280px, 70vw) - 20px);
            height: calc(min(280px, 70vw) - 20px);
            border-radius: 50%;
            background: conic-gradient(#ec4899 0deg, #f0f0f0 0deg);
            transition: all 0.3s ease;
            transform: translate(-50%, -50%);
        }
        
        .timer-progress-inner {
            position: absolute;
            top: 50%;
            left: 50%;
            width: calc(min(280px, 70vw) - 50px);
            height: calc(min(280px, 70vw) - 50px);
            border-radius: 50%;
            background: conic-gradient(#fb923c 0deg, #f8f9fa 0deg);
            transition: all 0.3s ease;
            transform: translate(-50%, -50%);
        }
        
        .timer-progress-minute {
            position: absolute;
            top: 50%;
            left: 50%;
            width: calc(min(280px, 70vw) - 80px);
            height: calc(min(280px, 70vw) - 80px);
            border-radius: 50%;
            background: conic-gradient(#fcd34d 0deg, #f8f9fa 0deg);
            transition: all 0.3s ease;
            opacity: 0;
            transform: translate(-50%, -50%);
        }
        
        .timer-progress-minute.visible {
            opacity: 1;
        }
        
        .radar-pulse {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border: 2px solid rgba(252, 211, 77, calc(var(--pulse-opacity, 0.8)));
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: radarPulse 1s ease-out infinite;
            z-index: 1;
            opacity: 0;
            pointer-events: none;
        }
        
        .radar-pulse.visible {
            opacity: 1;
        }
        
        /* Milestone Markers */
        .milestone-marker {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #fff;
            border: 3px solid #ddd;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 5;
            transform: translate(-50%, -50%);
        }
        
        .milestone-marker.reached {
            background: #28a745;
            border-color: #28a745;
            box-shadow: 0 0 8px rgba(40, 167, 69, 0.4);
        }
        
        .milestone-marker.current {
            background: #fb923c;
            border-color: #fb923c;
            box-shadow: 0 0 12px rgba(251, 146, 60, 0.6);
            animation: milestoneGlow 2s ease-in-out infinite;
        }
        
        .milestone-marker:hover {
            transform: translate(-50%, -50%) scale(1.3);
            box-shadow: 0 0 15px rgba(251, 146, 60, 0.8);
        }
        
        @keyframes milestoneGlow {
            0%, 100% { box-shadow: 0 0 12px rgba(251, 146, 60, 0.6); }
            50% { box-shadow: 0 0 20px rgba(251, 146, 60, 0.9); }
        }
        
        /* Milestone Tooltip */
        .milestone-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 16px 20px;
            border-radius: 12px;
            font-size: 0.9rem;
            white-space: normal;
            max-width: 350px;
            word-wrap: break-word;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transform: translate(-50%, -50%) scale(0.9);
            transition: all 0.3s ease;
            pointer-events: auto;
            left: 50%;
            top: 50%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .milestone-tooltip.show {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) scale(1);
        }
        
        @keyframes radarPulse {
            0% {
                width: 0;
                height: 0;
                opacity: calc(var(--pulse-opacity, 0.8));
                border-width: 3px;
            }
            50% {
                opacity: calc(var(--pulse-opacity, 0.8) * 0.6);
                border-width: 2px;
            }
            100% {
                width: min(280px, 70vw);  /* Responsive to match timer size */
                height: min(280px, 70vw);
                opacity: 0;
                border-width: 1px;
            }
        }
        
        .timer-inner {
            position: absolute;
            top: 50%;
            left: 50%;
            width: calc(min(280px, 70vw) - 120px);
            height: calc(min(280px, 70vw) - 120px);
            border-radius: 50%;
            background: #f0f0f0;
            box-shadow: 
                8px 8px 16px rgba(163, 177, 198, 0.6),
                -8px -8px 16px rgba(255, 255, 255, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 4;
            transform: translate(-50%, -50%);
        }
        
        .timer-display {
            font-size: 2.5rem;
            font-weight: 700;
            color: #333;
            font-family: 'Courier New', monospace;
            margin: 5px 0;
        }
        
        .timer-label {
            font-size: 0.9rem;
            color: #666;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .upcoming-fast-notice {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(147, 51, 234, 0.1));
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 15px;
            padding: 15px 20px;
            margin: 20px 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }
        
        .upcoming-fast-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .upcoming-text {
            flex: 1;
            color: #1e40af;
            font-size: 0.95rem;
            line-height: 1.4;
        }
        
        .upcoming-text strong {
            color: #1e3a8a;
            font-weight: 600;
        }
        
        .upcoming-text small {
            color: #64748b;
            font-size: 0.85rem;
        }
        
        .btn-start-early {
            background: linear-gradient(135deg, #3b82f6, #6366f1);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        
        .btn-start-early:hover {
            background: linear-gradient(135deg, #2563eb, #4f46e5);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        /* Actionable upcoming fast - within 6 hours, Start Early available */
        .upcoming-fast-notice.actionable {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.12), rgba(147, 51, 234, 0.12));
            border: 1px solid rgba(59, 130, 246, 0.25);
            animation: subtle-glow 3s ease-in-out infinite alternate;
        }
        
        @keyframes subtle-glow {
            from { box-shadow: 0 4px 12px rgba(59, 130, 246, 0.1); }
            to { box-shadow: 0 6px 20px rgba(59, 130, 246, 0.15); }
        }
        
        /* Informational upcoming fast - distant future, just awareness */
        .upcoming-fast-notice.informational {
            background: linear-gradient(135deg, rgba(107, 114, 128, 0.08), rgba(156, 163, 175, 0.08));
            border: 1px solid rgba(107, 114, 128, 0.15);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.03);
        }
        
        .upcoming-fast-notice.informational .upcoming-text {
            color: #6b7280;
        }
        
        .upcoming-fast-notice.informational .upcoming-text strong {
            color: #4b5563;
        }
        
        .upcoming-fast-notice.informational .upcoming-text small {
            color: #9ca3af;
        }
        
        .phase-info {
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.08), rgba(236, 72, 153, 0.08));
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 4px solid #fb923c;
        }
        
        .phase-title {
            color: #fb923c;
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 10px;
        }
        
        .phase-description {
            color: #666;
            font-size: 0.95rem;
            line-height: 1.5;
        }
        
        .start-fast-btn {
            width: 100%;
            max-width: 300px;
            margin: 0 auto 30px;
            padding: 20px 40px;
            border: none;
            border-radius: 15px;
            font-size: 1.3rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #fcd34d 0%, #fb923c 50%, #ec4899 100%);
            color: white;
            box-shadow: 0 8px 25px rgba(251, 146, 60, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .start-fast-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(251, 146, 60, 0.5);
        }
        
        .sticky-start-btn {
            position: fixed;
            bottom: 90px; /* Space above bottom nav (75px) + extra margin */
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            width: calc(100% - 40px);
            max-width: 350px;
            padding: 16px 32px;
            border: none;
            border-radius: 15px;
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #fcd34d 0%, #fb923c 50%, #ec4899 100%);
            color: white;
            box-shadow: 0 8px 25px rgba(251, 146, 60, 0.6), 0 0 0 1px rgba(255,255,255,0.1);
            text-transform: uppercase;
            letter-spacing: 1px;
            display: none;
        }
        
        /* Adjust for mobile safe area */
        @media (max-width: 768px) {
            .sticky-start-btn {
                bottom: max(90px, calc(75px + env(safe-area-inset-bottom) + 15px));
            }
        }
        
        .sticky-start-btn:hover {
            transform: translateX(-50%) translateY(-3px);
            box-shadow: 0 12px 35px rgba(251, 146, 60, 0.7), 0 0 0 1px rgba(255,255,255,0.2);
        }
        
        .sticky-start-btn .duration-badge {
            display: block;
            font-size: 0.9rem;
            opacity: 0.9;
            font-weight: 500;
            margin-top: 2px;
            text-transform: none;
            letter-spacing: normal;
        }
        
        .control-buttons {
            display: flex;
            gap: 15px;
            margin-top: auto;
            margin-bottom: 15px;
            padding-top: 20px;
            justify-content: center;
        }
        
        .btn {
            flex: 1;
            padding: 15px 20px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #fcd34d 0%, #fb923c 50%, #ec4899 100%);
            color: white;
        }
        
        .btn-secondary {
            background: transparent;
            border: 2px solid #fb923c;
            color: #fb923c;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(251, 146, 60, 0.4);
        }
        
        .scheduled-fast {
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.08), rgba(236, 72, 153, 0.08));
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 4px solid #fb923c;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .scheduled-fast:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(251, 146, 60, 0.15);
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.12), rgba(236, 72, 153, 0.12));
        }
        
        .scheduled-title {
            color: #fb923c;
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 10px;
        }
        
        .scheduled-info {
            color: #666;
            font-size: 0.95rem;
            line-height: 1.4;
        }
        
        .new-user-welcome {
            background: linear-gradient(135deg, rgba(40, 167, 69, 0.08), rgba(251, 146, 60, 0.08));
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 4px solid #28a745;
            text-align: center;
        }
        
        .welcome-title {
            color: #28a745;
            font-weight: 700;
            font-size: 1.3rem;
            margin-bottom: 12px;
        }
        
        .welcome-subtitle {
            color: #666;
            font-size: 1rem;
            line-height: 1.4;
            margin-bottom: 15px;
        }
        
        .welcome-hint {
            color: #999;
            font-size: 0.85rem;
            margin-top: 15px;
            font-style: italic;
        }
        
        .schedule-setup-state {
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.08), rgba(236, 72, 153, 0.08));
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 4px solid #fb923c;
            text-align: center;
        }
        
        .schedule-title {
            color: #fb923c;
            font-weight: 700;
            font-size: 1.3rem;
            margin-bottom: 12px;
        }
        
        .schedule-subtitle {
            color: #666;
            font-size: 1rem;
            line-height: 1.4;
            margin-bottom: 15px;
        }
        
        .dual-button-group {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }
        
        .schedule-btn-primary {
            flex: 1;
            padding: 15px 20px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #fb923c 0%, #ec4899 100%);
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .schedule-btn-secondary {
            flex: 1;
            padding: 15px 20px;
            border: 2px solid #fb923c;
            border-radius: 10px;
            background: transparent;
            color: #fb923c;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .schedule-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(251, 146, 60, 0.3);
        }
        
        .schedule-btn-secondary:hover {
            transform: translateY(-2px);
            background: rgba(251, 146, 60, 0.05);
        }

        /* Hunger Coach Card - Updated Design System */
        .hunger-coach-card {
            margin: 25px 0;
            padding: 24px;
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.08), rgba(14, 165, 233, 0.06));
            border-radius: 16px;
            border: 1px solid rgba(6, 182, 212, 0.15);
            box-shadow: 0 4px 16px rgba(6, 182, 212, 0.08);
            min-height: 140px;
            transition: all 0.4s ease;
            opacity: 1;
            transform: translateY(0);
            cursor: pointer;
        }

        .hunger-coach-card.hidden {
            display: none;
        }

        .hunger-coach-card.slide-in {
            animation: slideInUp 0.5s ease-out;
        }

        .hunger-coach-card.fading {
            opacity: 0.6;
        }

        /* Card Content Container */
        .card-content {
            display: flex;
            flex-direction: column;
            height: 100%;
            justify-content: space-between;
        }

        /* Inline Icon + Message */
        .card-message {
            font-size: 17px;
            font-weight: 500;
            line-height: 1.5;
            color: #1f2937;
            margin: 0 0 16px 0;
            opacity: 1;
            transition: opacity 0.4s ease;
        }

        .card-message.fading {
            opacity: 0;
        }

        .inline-icon {
            font-size: 1.3rem;
            margin-right: 8px;
            vertical-align: baseline;
        }

        /* Extended Content */
        .card-extended {
            margin: 16px 0;
            padding-top: 16px;
            border-top: 1px solid rgba(6, 182, 212, 0.15);
            transition: all 0.3s ease;
        }

        .extended-text {
            font-size: 15px;
            font-weight: 400;
            line-height: 1.4;
            color: #6b7280;
            margin: 0;
        }

        /* Expanded state */
        .hunger-coach-card.expanded {
            min-height: 200px;
        }

        /* See More Link */
        .see-more-link {
            color: #0891b2;
            font-size: 14px;
            font-weight: 600;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            margin-top: auto;
            transition: all 0.2s ease;
        }

        .see-more-link:hover {
            color: #0e7490;
            text-decoration: underline;
        }

        .see-more-link:after {
            content: "→";
            margin-left: 4px;
            transition: transform 0.2s ease;
        }

        .see-more-link:hover:after {
            transform: translateX(2px);
        }

        /* Slide-in Animation */
        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Hover Effect */
        .hunger-coach-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(6, 182, 212, 0.12);
        }

        /* Benefits Card - Matching Design System */
        .benefits-card {
            margin: 25px 0;
            padding: 24px;
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.08), rgba(5, 150, 105, 0.06));
            border-radius: 16px;
            border: 1px solid rgba(16, 185, 129, 0.15);
            box-shadow: 0 4px 16px rgba(16, 185, 129, 0.08);
            min-height: 140px;
            transition: all 0.4s ease;
            opacity: 1;
            transform: translateY(0);
            cursor: pointer;
        }

        .benefits-card.hidden {
            display: none;
        }

        .benefits-card.slide-in {
            animation: slideInUp 0.5s ease-out;
        }

        .benefits-card.fading {
            opacity: 0.6;
        }

        .benefits-card.expanded {
            min-height: 200px;
            box-shadow: 0 8px 32px rgba(16, 185, 129, 0.15);
        }

        .benefits-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(16, 185, 129, 0.12);
        }

        .time-display {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .time-item {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin: 12px 0;
            min-height: 24px;
        }
        
        .time-label {
            color: #666;
            font-weight: 500;
            font-size: 0.95rem;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .time-value {
            color: #333;
            font-weight: 600;
            font-size: 0.95rem;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            text-align: right;
            line-height: 1.2;
        }
        
        .time-value-container {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 8px;
        }
        
        .adjust-time-btn {
            background: transparent;
            border: 1px solid #ddd;
            color: #666;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.7;
        }
        
        .adjust-time-btn:hover {
            border-color: #fb923c;
            color: #fb923c;
            opacity: 1;
        }
        
        .time-adjustment-controls {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 6px;
            flex-wrap: wrap;
        }
        
        .time-adjustment-controls input[type="time"],
        .time-adjustment-controls select {
            padding: 4px 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.8rem;
            font-family: inherit;
        }
        
        .time-adjustment-controls input[type="time"]:focus,
        .time-adjustment-controls select:focus {
            border-color: #fb923c;
            outline: none;
            box-shadow: 0 0 0 2px rgba(251, 146, 60, 0.1);
        }
        
        .apply-adjustment-btn,
        .cancel-adjustment-btn {
            padding: 4px 8px;
            border: none;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .apply-adjustment-btn {
            background: #28a745;
            color: white;
        }
        
        .apply-adjustment-btn:hover {
            background: #218838;
        }
        
        .cancel-adjustment-btn {
            background: #6c757d;
            color: white;
        }
        
        .cancel-adjustment-btn:hover {
            background: #5a6268;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 25px 0;
        }
        
        .stat-item {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #333;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #666;
            margin-top: 5px;
        }
        
        .welcome-message {
            text-align: center;
            color: white;
            padding: 20px 0;
            margin-bottom: 20px;
        }
        
        .welcome-message h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
            font-weight: 700;
        }
        
        .welcome-message p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .customize-duration {
            text-align: center;
            margin: 15px 0;
        }
        
        .customize-btn {
            background: transparent;
            border: 1px solid #fb923c;
            color: #fb923c;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .customize-btn:hover {
            background: rgba(251, 146, 60, 0.1);
            transform: translateY(-1px);
        }
        
        .duration-selector {
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.05), rgba(236, 72, 153, 0.05));
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            border: 1px solid rgba(251, 146, 60, 0.2);
            transition: all 0.3s ease;
        }
        
        .duration-presets h4 {
            color: #fb923c;
            font-size: 1.1rem;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .preset-btn {
            position: relative;
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }
        
        .preset-btn:hover {
            border-color: #fb923c;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(251, 146, 60, 0.2);
        }
        
        .preset-btn.active {
            border-color: #fb923c;
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.1), rgba(236, 72, 153, 0.1));
            box-shadow: 0 4px 12px rgba(251, 146, 60, 0.3);
        }
        
        .preset-btn.selected-confirmation {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(251, 146, 60, 0.1));
            border-color: #22c55e;
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
            transform: scale(1.02);
        }
        
        .preset-btn .checkmark {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 20px;
            height: 20px;
            background: #22c55e;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            font-weight: bold;
        }
        
        .preset-btn.selected-confirmation .checkmark {
            display: flex;
        }
        
        .preset-btn .duration {
            display: block;
            font-weight: 700;
            font-size: 1.1rem;
            color: #333;
            margin-bottom: 4px;
        }
        
        .preset-btn .description {
            display: block;
            font-size: 0.8rem;
            color: #666;
            line-height: 1.2;
        }
        
        .custom-duration {
            border-top: 1px solid rgba(251, 146, 60, 0.2);
            padding-top: 15px;
        }
        
        .custom-duration label {
            display: block;
            color: #fb923c;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .custom-input {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .custom-input input {
            width: 80px;
            padding: 8px 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 1rem;
            text-align: center;
        }
        
        .custom-input input:focus {
            border-color: #fb923c;
            outline: none;
            box-shadow: 0 0 0 3px rgba(251, 146, 60, 0.1);
        }
        
        .custom-input span {
            color: #666;
            font-weight: 500;
        }
        
        .apply-custom-btn {
            background: linear-gradient(135deg, #fcd34d 0%, #fb923c 50%, #ec4899 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .apply-custom-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(251, 146, 60, 0.4);
        }
        
        .start-time-section {
            border-top: 1px solid rgba(251, 146, 60, 0.2);
            padding-top: 15px;
            margin-top: 15px;
        }
        
        .start-time-section > label {
            display: block;
            color: #fb923c;
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        .start-time-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .radio-option {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            color: #333;
            font-weight: 500;
        }
        
        .radio-option input[type="radio"] {
            margin: 0;
        }
        
        .time-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
            padding: 8px;
            background: rgba(251, 146, 60, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(251, 146, 60, 0.1);
        }
        
        .time-input-group input[type="time"] {
            padding: 6px 10px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 0.95rem;
            font-family: inherit;
        }
        
        .time-input-group input[type="time"]:focus {
            border-color: #fb923c;
            outline: none;
            box-shadow: 0 0 0 2px rgba(251, 146, 60, 0.1);
        }
        
        .time-input-group select {
            padding: 6px 10px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 0.95rem;
            background: white;
            cursor: pointer;
        }
        
        .time-input-group select:focus {
            border-color: #fb923c;
            outline: none;
            box-shadow: 0 0 0 2px rgba(251, 146, 60, 0.1);
        }

        /* Fast Completion State */
        .completion-state {
            text-align: center;
            animation: fadeInUp 0.6s ease;
        }
        
        .completion-header {
            margin-bottom: 30px;
        }
        
        .completion-header h2 {
            color: #28a745;
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 10px;
        }
        
        .completion-header .celebration {
            font-size: 3rem;
            margin-bottom: 15px;
        }
        
        .completion-summary {
            background: linear-gradient(135deg, rgba(40, 167, 69, 0.08), rgba(251, 146, 60, 0.08));
            border-radius: 20px;
            padding: 25px;
            margin: 25px 0;
            border: 2px solid #28a745;
            box-shadow: 0 8px 25px rgba(40, 167, 69, 0.15);
        }
        
        .summary-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 25px;
        }
        
        .summary-stat {
            text-align: center;
        }
        
        .summary-stat .value {
            font-size: 2.2rem;
            font-weight: 700;
            color: #28a745;
            display: block;
            margin-bottom: 5px;
        }
        
        .summary-stat .label {
            font-size: 0.9rem;
            color: #666;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .milestones-achieved {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .milestones-achieved h4 {
            color: #28a745;
            font-size: 1.1rem;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .milestone-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .milestone-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #28a745;
        }
        
        .milestone-item .icon {
            font-size: 1.3rem;
            width: 30px;
            text-align: center;
        }
        
        .milestone-item .info {
            flex: 1;
        }
        
        .milestone-item .title {
            font-weight: 600;
            color: #333;
            font-size: 0.95rem;
            margin-bottom: 2px;
        }
        
        .milestone-item .time {
            font-size: 0.8rem;
            color: #666;
        }
        
        .completion-actions {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 25px;
        }
        
        .refeed-notes-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 18px 30px;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 6px 20px rgba(40, 167, 69, 0.3);
        }
        
        .refeed-notes-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(40, 167, 69, 0.4);
        }
        
        .new-fast-btn {
            background: transparent;
            border: 2px solid #fb923c;
            color: #fb923c;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .new-fast-btn:hover {
            background: rgba(251, 146, 60, 0.1);
            transform: translateY(-1px);
        }
        
        /* Confetti Canvas */
        #confettiCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .timer-card {
                min-height: 500px;
                max-height: none;
                padding: 18px 20px 25px 20px;
                justify-content: flex-start;
            }
            
            .control-buttons {
                margin-top: auto;
                margin-bottom: 12px;
                padding-top: 15px;
            }
            
            .circular-timer {
                width: min(280px, 70vw);
                height: min(280px, 70vw);
                margin: 20px auto 15px;
            }
            
            .status-text {
                margin: 25px 0 15px 0;
                font-size: 1rem;
            }
            
            .control-buttons {
                margin: 15px 0 25px 0;
            }
            
            .timer-display {
                font-size: 2.5rem;
            }
            
            .control-buttons {
                flex-direction: column;
            }
            
            .preset-buttons {
                grid-template-columns: 1fr;
            }
            
            .summary-stats {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .completion-header h2 {
                font-size: 1.6rem;
            }
            
            .completion-header .celebration {
                font-size: 2.5rem;
            }
        }
        
        /* Bottom Navigation */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(251, 146, 60, 0.2);
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 8px 0 max(8px, env(safe-area-inset-bottom));
            z-index: 1000;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.1);
        }
        
        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            color: #666;
            transition: all 0.3s ease;
            padding: 8px 12px;
            border-radius: 12px;
            min-width: 50px;
            position: relative;
        }
        
        .nav-item:hover {
            color: #fb923c;
            transform: translateY(-2px);
        }
        
        .nav-item.active {
            color: #fb923c;
            background: rgba(251, 146, 60, 0.1);
        }
        
        .nav-item.nav-primary {
            transform: scale(1.1);
            background: linear-gradient(135deg, #fcd34d 0%, #fb923c 50%, #ec4899 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(251, 146, 60, 0.3);
        }
        
        .nav-item.nav-primary:hover {
            transform: scale(1.15) translateY(-2px);
            box-shadow: 0 6px 20px rgba(251, 146, 60, 0.4);
            color: white;
        }
        
        .nav-item.nav-primary.active {
            color: white;
            background: linear-gradient(135deg, #fcd34d 0%, #fb923c 50%, #ec4899 100%);
        }
        
        .nav-icon {
            width: 24px;
            height: 24px;
            margin-bottom: 4px;
            stroke-width: 2;
        }
        
        .nav-primary .nav-icon {
            width: 28px;
            height: 28px;
        }
        
        .nav-label {
            font-size: 10px;
            font-weight: 500;
            text-align: center;
            line-height: 1.2;
        }
        
        .nav-primary .nav-label {
            font-size: 11px;
            font-weight: 600;
        }
        
        
        @media (max-width: 768px) {
            .bottom-nav {
                padding: 6px 0 max(6px, env(safe-area-inset-bottom));
            }
            
            .nav-item {
                padding: 6px 8px;
            }
            
            .nav-icon {
                width: 20px;
                height: 20px;
                margin-bottom: 2px;
            }
            
            .nav-primary .nav-icon {
                width: 24px;
                height: 24px;
            }
            
            .nav-label {
                font-size: 9px;
            }
            
            .nav-primary .nav-label {
                font-size: 10px;
            }
            
            body {
                padding-bottom: 75px;
            }
            
            html, body {
                overflow-x: hidden;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="welcome-message">
            <h1>Welcome back!</h1>
            <p>Ready for your next fasting session?</p>
        </div>
        
        <div class="timer-card">
            <!-- Pre-Fast State -->
            <div id="preFastState">
                <!-- New User Welcome State -->
                <div id="newUserWelcome" class="new-user-welcome" style="display: none;">
                    <div class="welcome-title">🎉 Welcome to Your Fasting Journey!</div>
                    <div class="welcome-subtitle">Ready to start your first fast?</div>
                </div>
                
                <!-- Schedule Setup State (for returning users) -->
                <div id="scheduleSetupState" class="schedule-setup-state" style="display: none;">
                    <div class="schedule-title">📅 Want to make fasting easier?</div>
                    <div class="schedule-subtitle">Set up a regular schedule to stay on track</div>
                    <button class="schedule-btn-secondary" onclick="showScheduleSetup()" style="margin-top: 15px;">Set My Schedule</button>
                </div>
                
                <!-- Scheduled Fast State -->
                <div id="scheduledFastInfo" class="scheduled-fast" style="display: none;" onclick="showScheduleSetup()">
                    <div class="scheduled-title">🗓️ Next Scheduled Fast</div>
                    <div class="scheduled-info">
                        <span id="scheduledFastDetails">Tomorrow at 8:00 PM • 24-hour fast</span><br>
                        <small style="opacity: 0.7;">Tap to modify schedule</small>
                    </div>
                </div>
                
                <button class="start-fast-btn" id="startFastBtn" onclick="startFast()">
                    Start Your First Fast
                </button>
                
                <button class="sticky-start-btn" id="stickyStartBtn" onclick="startFast()" style="display: none;">
                    <span id="stickyBtnText">Start 24h Fast</span>
                    <span class="duration-badge" id="stickyBtnBadge">Selected: 24 hours</span>
                </button>
                
                <div id="newUserHint" class="welcome-hint" style="display: none;">
                    Choose your duration below or start with 24 hours
                </div>
                
                
                <div class="customize-duration">
                    <button class="customize-btn" onclick="toggleDurationSelector()">
                        Customize Duration ⚙️
                    </button>
                </div>
                
                <div class="duration-selector" id="durationSelector" style="display: none;">
                    <div class="duration-presets">
                        <h4>Choose Duration</h4>
                        <div class="preset-buttons">
                            <button class="preset-btn active" data-hours="24" onclick="selectDuration(24)">
                                <span class="duration">24h</span>
                                <span class="description">Metabolic reset & fat burning</span>
                                <span class="checkmark">✓</span>
                            </button>
                            <button class="preset-btn" data-hours="36" onclick="selectDuration(36)">
                                <span class="duration">36h</span>
                                <span class="description">Deep ketosis & mental clarity</span>
                                <span class="checkmark">✓</span>
                            </button>
                            <button class="preset-btn" data-hours="48" onclick="selectDuration(48)">
                                <span class="duration">48h</span>
                                <span class="description">Peak autophagy & cellular renewal</span>
                                <span class="checkmark">✓</span>
                            </button>
                            <button class="preset-btn" data-hours="72" onclick="selectDuration(72)">
                                <span class="duration">72h</span>
                                <span class="description">Extended therapeutic benefits</span>
                                <span class="checkmark">✓</span>
                            </button>
                        </div>
                        
                        <div class="custom-duration">
                            <label for="customHours">Custom Duration:</label>
                            <div class="custom-input">
                                <input type="number" id="customHours" min="1" max="168" placeholder="24">
                                <span>hours</span>
                                <button class="apply-custom-btn" onclick="applyCustomDuration()">Apply Custom Duration</button>
                            </div>
                        </div>
                        
                        <div class="start-time-section">
                            <label>Start Time:</label>
                            <div class="start-time-options">
                                <label class="radio-option">
                                    <input type="radio" name="startTime" value="now" checked onchange="toggleStartTimeInputs()">
                                    <span>Start now</span>
                                </label>
                                <label class="radio-option">
                                    <input type="radio" name="startTime" value="custom" onchange="toggleStartTimeInputs()">
                                    <span>Started at:</span>
                                </label>
                            </div>
                            <div class="time-input-group" id="timeInputGroup" style="display: none;">
                                <input type="time" id="startTimeInput" onchange="updateSelectedStartTime(); updateStartButtonText();">
                                <select id="startDateOffset" onchange="updateSelectedStartTime(); updateStartButtonText();">
                                    <option value="0">Today</option>
                                    <option value="1">Yesterday</option>
                                    <option value="2">2 days ago</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="totalFasts">0</div>
                        <div class="stat-label">Completed Fasts</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="longestFast">0h</div>
                        <div class="stat-label">Longest Fast</div>
                    </div>
                </div>
            </div>
            
            <!-- Active Fast State -->
            <div id="activeFastState" style="display: none;">
                <div class="status-text">
                    <span class="status-indicator fasting" id="statusIndicator"></span>
                    <span id="statusText">Fasting Active</span>
                </div>
                
                <div class="circular-timer">
                    <div class="timer-progress-outer" id="timerProgressOuter"></div>
                    <div class="timer-progress-inner" id="timerProgressInner"></div>
                    <div class="timer-progress-minute" id="timerProgressMinute"></div>
                    <div class="radar-pulse" id="radarPulse"></div>
                    
                    <!-- Milestone Markers -->
                    <div id="milestoneMarkers"></div>
                    
                    <div class="timer-inner">
                        <div class="timer-display" id="timerDisplay">12:30</div>
                        <div class="timer-label" id="timerLabel">ELAPSED</div>
                    </div>
                </div>

                <!-- Contextual Cards (Hunger Coach + Benefits) -->
                <!-- Hunger Coach Card -->
                <div class="hunger-coach-card hidden" id="hungerCoachCard" onclick="handleCardTap(event)">
                    <!-- Inline Icon + Message Content -->
                    <div class="card-content">
                        <p class="card-message" id="hungerCardMessage">
                            <span class="inline-icon" id="hungerCardIcon">🍵</span>
                            <span id="hungerCardText">Loading helpful tips...</span>
                        </p>

                        <!-- Extended content shown on tap -->
                        <div class="card-extended" id="hungerCardExtended" style="display: none;">
                            <p class="extended-text" id="hungerExtendedText">Additional context and tips will appear here when you tap the card.</p>
                        </div>

                        <!-- See More Link -->
                        <a href="#" class="see-more-link" id="hungerSeeMoreLink" onclick="handleSeeMoreClick(event)">See More</a>
                    </div>
                </div>

                <!-- Benefits Card -->
                <div class="benefits-card hidden" id="benefitsCard" onclick="handleBenefitsCardTap(event)">
                    <!-- Inline Icon + Message Content -->
                    <div class="card-content">
                        <p class="card-message" id="benefitsCardMessage">
                            <span class="inline-icon" id="benefitsCardIcon">💰</span>
                            <span id="benefitsCardText">Loading benefits...</span>
                        </p>

                        <!-- Extended content shown on tap -->
                        <div class="card-extended" id="benefitsCardExtended" style="display: none;">
                            <p class="extended-text" id="benefitsExtendedText">Detailed benefits information will appear here when you tap the card.</p>
                        </div>

                        <!-- See More Link -->
                        <a href="#" class="see-more-link" id="benefitsSeeMoreLink" onclick="handleBenefitsSeeMoreClick(event)">View Dashboard</a>
                    </div>
                </div>

                <div class="time-display">
                    <div class="time-item">
                        <span class="time-label">Started</span>
                        <div class="time-value-container">
                            <span class="time-value" id="startTime">8:00 PM</span>
                            <button class="adjust-time-btn" id="adjustStartBtn" onclick="toggleStartTimeAdjustment()">
                                <small>adjust</small>
                            </button>
                        </div>
                    </div>
                    <div class="time-item" id="startTimeAdjustment" style="display: none;">
                        <div class="time-adjustment-controls">
                            <input type="time" id="adjustTimeInput">
                            <select id="adjustDateOffset">
                                <option value="0">Today</option>
                                <option value="1">Yesterday</option>
                                <option value="2">2 days ago</option>
                            </select>
                            <button class="apply-adjustment-btn" onclick="applyStartTimeAdjustment()">Apply</button>
                            <button class="cancel-adjustment-btn" onclick="cancelStartTimeAdjustment()">Cancel</button>
                        </div>
                    </div>
                    <div class="time-item">
                        <span class="time-label">Target End</span>
                        <span class="time-value" id="endTime">8:00 PM</span>
                    </div>
                </div>
                
                <div class="phase-info" id="phaseInfo">
                    <div class="phase-title" id="phaseTitle">Metabolic Shift</div>
                    <div class="phase-description" id="phaseDescription">
                        Your body is starting to switch from glucose to fat burning. Energy may fluctuate.
                    </div>
                </div>
                
                <div class="control-buttons">
                    <button class="btn btn-secondary" onclick="endFast()">
                        End Fast
                    </button>
                    <button class="btn btn-secondary" onclick="resetTimer()">
                        Reset
                    </button>
                </div>
            </div>
            
            <!-- Fast Completion State -->
            <div id="completionState" style="display: none;">
                <div class="completion-state">
                    <div class="completion-header">
                        <div class="celebration">🎉</div>
                        <h2>Fast Complete!</h2>
                        <p style="color: #666; font-size: 1.1rem;">Congratulations on completing your fast!</p>
                    </div>
                    
                    <div class="completion-summary">
                        <div class="summary-stats">
                            <div class="summary-stat">
                                <span class="value" id="completionDuration">24:00</span>
                                <span class="label">Total Time</span>
                            </div>
                            <div class="summary-stat">
                                <span class="value" id="completionCalories">~1,800</span>
                                <span class="label">Est. Calories Burned</span>
                            </div>
                        </div>
                        
                        <div class="milestones-achieved">
                            <h4>🏆 Milestones Achieved</h4>
                            <div class="milestone-list" id="completionMilestones">
                                <!-- Milestones will be populated here -->
                            </div>
                        </div>
                    </div>
                    
                    <div class="completion-actions">
                        <button class="refeed-notes-btn" onclick="openRefeedNotes()">
                            📝 Log Refeed Notes
                        </button>
                        <button class="new-fast-btn" onclick="startNewFast()">
                            Start New Fast
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Confetti Canvas -->
    <canvas id="confettiCanvas"></canvas>

    <!-- Hunger Coach Module -->
    <script src="/js/modules/hunger-coach.js"></script>
    <script src="/js/modules/notification-service.js"></script>
    <script src="/js/modules/global-notification-manager.js"></script>

    <!-- Contextual Cards System -->
    <script src="/js/components/ContextualCard.js"></script>
    <script src="/js/components/HungerCoachCard.js"></script>
    <script src="/js/components/BenefitsCard.js"></script>
    <script src="/js/services/MealTimeDetector.js"></script>
    <script src="/js/services/BenefitsCalculator.js"></script>
    <script src="/js/services/BenefitsDataService.js"></script>
    <script src="/js/managers/CardRotationManager.js"></script>

    <script>
        // Timer state
        let isRunning = false;
        let fastStartTime = null;
        let elapsedTime = 0;
        let timerInterval = null;
        let fastDuration = 24; // Default 24-hour fast
        let selectedDuration = 24; // Selected duration for next fast
        let selectedStartTime = null; // Selected start time (null = start now)
        
        // Session management - use global function from PageGuard
        const globalSessionId = window.getSessionId();
        let currentFastId = null;

        // Contextual Cards System
        let cardRotationManager = null;
        let notificationService = null;
        const CARD_ROTATION_INTERVAL = 12000; // 12 seconds

        // Legacy hunger coach for backwards compatibility
        let hungerCoach = null;

        // Milestone definitions
        const milestones = [
            {
                hours: 12,
                title: "Glycogen Depletion Begins",
                message: "Your body is running low on stored glycogen and beginning to shift toward fat burning.",
                icon: "⚡"
            },
            {
                hours: 18,
                title: "Ketosis Transition",
                message: "Ketones are rising - you're switching to fat for fuel. Mental clarity often improves.",
                icon: "🔥"
            },
            {
                hours: 30,
                title: "Sustained Fat-Burning",
                message: "Fat is now your body's main energy source. You're in a deep metabolic state.",
                icon: "💪"
            },
            {
                hours: 48,
                title: "Cellular Renewal (Autophagy)",
                message: "Your cells are recycling and repairing. Maximum therapeutic benefits activated.",
                icon: "✨"
            }
        ];
        
        // Fasting phases with descriptions
        const phases = {
            0: {
                title: "Getting Started",
                description: "Your body is beginning to use stored glucose and transitioning away from constant feeding."
            },
            4: {
                title: "Early Adaptation", 
                description: "Blood sugar stabilizing. Initial hunger pangs are normal as your body adjusts."
            },
            8: {
                title: "Metabolic Shift",
                description: "Your body is starting to switch from glucose to fat burning. Energy may fluctuate."
            },
            12: {
                title: "Fat Burning Mode",
                description: "Ketone production increasing. You may start feeling more focused and energized."
            },
            16: {
                title: "Deep Ketosis",
                description: "Significant ketone production. Mental clarity improving, hunger often subsides."
            },
            24: {
                title: "Optimal Fat Burning",
                description: "Peak fat oxidation and ketone production. Maximum metabolic benefits activated."
            },
            36: {
                title: "Advanced Ketosis", 
                description: "Deep therapeutic ketosis. Enhanced autophagy and cellular repair processes."
            },
            48: {
                title: "Extended Benefits",
                description: "Maximum autophagy, growth hormone elevation, and metabolic optimization."
            }
        };

        // Card Rotation Manager Functions
        async function initializeCardRotationManager() {
            try {
                if (window.CardRotationManager) {
                    cardRotationManager = new CardRotationManager({
                        rotationInterval: CARD_ROTATION_INTERVAL,
                        mealTimeToleranceMinutes: 30,
                        enableRotation: true
                    });

                    await cardRotationManager.init();
                    console.log('Card Rotation Manager initialized successfully');
                    return true;
                } else {
                    console.warn('CardRotationManager not available, falling back to legacy hunger coach');
                    return await initializeLegacyHungerCoach();
                }
            } catch (error) {
                console.error('Failed to initialize Card Rotation Manager:', error);
                console.log('Falling back to legacy hunger coach');
                return await initializeLegacyHungerCoach();
            }
        }

        // Legacy Hunger Coach Functions (fallback)
        async function initializeLegacyHungerCoach() {
            try {
                hungerCoach = new HungerCoach();
                await hungerCoach.init();
                console.log('Legacy Hunger Coach initialized');
                return true;
            } catch (error) {
                console.error('Failed to initialize Legacy Hunger Coach:', error);
                hungerCoach = null;
                return false;
            }
        }

        // Notification Service Functions
        async function initializeNotificationService() {
            try {
                notificationService = new NotificationService();
                console.log('Notification Service initialized');

                // Request permission on first initialization
                if (notificationService.permission === 'default') {
                    await notificationService.requestPermission();
                }
            } catch (error) {
                console.error('Failed to initialize Notification Service:', error);
                notificationService = null;
            }
        }

        async function showContextualCards() {
            if (cardRotationManager && isRunning) {
                try {
                    // Get user meal times for context
                    const mealtimes1 = await getUserMealtimes();

                    // Update fast state in card rotation manager
                    cardRotationManager.updateFastState(isRunning, fastStartTime, mealtimes1);

                    console.log('Contextual cards updated for active fast');
                } catch (error) {
                    console.error('Error showing contextual cards:', error);

                    // Fallback to legacy hunger coach
                    await showLegacyHungerCoachCard();
                }
            } else if (hungerCoach && isRunning) {
                // Fallback to legacy implementation
                await showLegacyHungerCoachCard();
            }
        }

        function hideContextualCards() {
            if (cardRotationManager) {
                try {
                    // Hide cards by updating fast state
                    cardRotationManager.updateFastState(false, null, null);
                    console.log('Contextual cards hidden');
                } catch (error) {
                    console.error('Error hiding contextual cards:', error);
                    hideLegacyHungerCoachCard();
                }
            } else {
                // Fallback to legacy implementation
                hideLegacyHungerCoachCard();
            }
        }

        // Legacy implementations for fallback
        async function showLegacyHungerCoachCard() {
            const hungerCard = document.getElementById('hungerCoachCard');
            if (hungerCard && hungerCoach && isRunning) {
                hungerCard.classList.remove('hidden');
                hungerCard.classList.add('slide-in');
                await updateHungerCard();
                startTipRotation();
            }
        }

        function hideLegacyHungerCoachCard() {
            const hideHungerCard = document.getElementById('hungerCoachCard');
            if (hideHungerCard) {
                hideHungerCard.classList.add('hidden');
                hideHungerCard.classList.remove('slide-in');
                stopTipRotation();
            }
        }

        async function updateHungerCard() {
            if (!hungerCoach) return;

            const textElement = document.getElementById('hungerCardText');
            const iconElement = document.getElementById('hungerCardIcon');

            if (!textElement || !iconElement) return;

            try {
                // Get contextual tip based on current fast state
                const updateMealtimes = await getUserMealtimes();
                const contextualTip = hungerCoach.getContextualTip(fastStartTime, updateMealtimes);

                // Add fade effect to content that will change
                const messageElement = document.getElementById('hungerCardMessage');
                messageElement.classList.add('fading');

                setTimeout(() => {
                    // Update icon based on tip type and context
                    const icons = {
                        'educational': '🧠',
                        'action': getActionIcon(contextualTip.text),
                        'motivational': '⭐',
                        'reassurance': '🍵'
                    };
                    iconElement.textContent = icons[contextualTip.type] || '🍵';

                    // Update message text (inline format)
                    textElement.textContent = contextualTip.text;

                    // Remove fade effect
                    messageElement.classList.remove('fading');
                }, 300);

            } catch (error) {
                console.error('Error updating hunger card:', error);
                textElement.textContent = 'Remember: hunger comes in waves, not constant streams. This feeling will pass.';
                iconElement.textContent = '🍵';
            }
        }

        function getActionIcon(tipText) {
            if (tipText.includes('water') || tipText.includes('drink') || tipText.includes('tea')) {
                return '💧';
            } else if (tipText.includes('walk') || tipText.includes('movement') || tipText.includes('exercise')) {
                return '🚶';
            } else if (tipText.includes('breath') || tipText.includes('meditation') || tipText.includes('mindful')) {
                return '🧘';
            } else {
                return '💪';
            }
        }


        function handleCardTap(event) {
            // Prevent card tap when See More link is clicked
            if (event.target.id === 'hungerSeeMoreLink') {
                return;
            }

            const card = document.getElementById('hungerCoachCard');
            const extendedContent = document.getElementById('hungerCardExtended');
            const extendedText = document.getElementById('hungerExtendedText');

            if (!card || !extendedContent) return;

            const isExpanded = card.classList.contains('expanded');

            if (isExpanded) {
                // Collapse
                extendedContent.style.display = 'none';
                card.classList.remove('expanded');
            } else {
                // Expand with additional context
                const contextualInfo = getExtendedTipContent();
                extendedText.textContent = contextualInfo;

                extendedContent.style.display = 'block';
                card.classList.add('expanded');

                // Add slight bounce animation
                card.style.transform = 'scale(1.02)';
                setTimeout(() => {
                    card.style.transform = '';
                }, 200);
            }
        }

        function getExtendedTipContent() {
            if (!fastStartTime) return 'Keep up the great work with your fast!';

            const fastElapsedHours = (Date.now() - new Date(fastStartTime).getTime()) / (1000 * 60 * 60);

            if (fastElapsedHours < 6) {
                return 'You\'re in the early stages. Your body is still adjusting to the fasting state. Stay hydrated and keep busy.';
            } else if (fastElapsedHours < 12) {
                return 'Your glycogen stores are being depleted. This is when hunger can feel strongest, but it will pass.';
            } else if (elapsedHours < 18) {
                return 'You\'re entering deeper metabolic changes. Many people find hunger actually decreases around this time.';
            } else if (elapsedHours < 24) {
                return 'You\'re approaching or in ketosis. Mental clarity often improves and hunger becomes more manageable.';
            } else {
                return 'You\'re in extended fasting territory. Your body has adapted well. Trust the process and listen to your body.';
            }
        }

        function handleSeeMoreClick(event) {
            // Prevent event bubbling to card tap handler
            event.preventDefault();
            event.stopPropagation();

            // TODO: When learning library is implemented, navigate to hunger management section
            // For now, provide feedback that the feature will be available soon
            console.log('See More clicked - will navigate to learning library');

            // Show temporary feedback
            const seeMoreLink = document.getElementById('hungerSeeMoreLink');
            const originalText = seeMoreLink.textContent;

            seeMoreLink.textContent = 'Coming Soon!';
            seeMoreLink.style.color = '#059669';

            setTimeout(() => {
                seeMoreLink.textContent = originalText;
                seeMoreLink.style.color = '';
            }, 2000);

            // Show next tip to keep engagement
            setTimeout(async () => {
                await updateHungerCard();
            }, 3000);
        }

        // Benefits Card Event Handlers
        function handleBenefitsCardTap(event) {
            // Prevent card tap when See More link is clicked
            if (event.target.id === 'benefitsSeeMoreLink') {
                return;
            }

            const benefitsCard = document.getElementById('benefitsCard');
            const benefitsExtendedContent = document.getElementById('benefitsCardExtended');
            const benefitsExtendedText = document.getElementById('benefitsExtendedText');

            if (!benefitsCard || !benefitsExtendedContent) return;

            // Toggle expanded state
            const benefitsIsExpanded = benefitsCard.classList.contains('expanded');

            if (!benefitsIsExpanded) {
                // Expand the card
                benefitsCard.classList.add('expanded');
                benefitsExtendedContent.style.display = 'block';

                // Update extended content if needed
                if (!benefitsExtendedText.textContent || benefitsExtendedText.textContent === 'Detailed benefits information will appear here when you tap the card.') {
                    updateBenefitsExtendedContent();
                }

                // Notify card rotation manager about user interaction
                if (cardRotationManager) {
                    cardRotationManager.onCardTap('benefits', event);
                }
            } else {
                // Collapse the card
                benefitsCard.classList.remove('expanded');
                benefitsExtendedContent.style.display = 'none';
            }
        }

        function handleBenefitsSeeMoreClick(event) {
            // Prevent event bubbling to card tap handler
            event.preventDefault();
            event.stopPropagation();

            // Navigate to dashboard benefits tab
            window.location.href = '/dashboard#benefits';
        }

        function updateBenefitsExtendedContent() {
            const benefitsExtendedTextElement = document.getElementById('benefitsExtendedText');
            if (!benefitsExtendedTextElement) return;

            // Calculate some quick benefits for display
            const benefitsElapsedHours = Math.floor(getElapsedTime() / (60 * 60 * 1000));
            const estimatedMealsSkipped = Math.floor(benefitsElapsedHours / 8); // Rough estimate
            const estimatedSavings = estimatedMealsSkipped * 10; // $10 per meal estimate

            if (estimatedSavings > 0) {
                benefitsExtendedTextElement.textContent = `So far you've skipped ${estimatedMealsSkipped} meal${estimatedMealsSkipped === 1 ? '' : 's'} and saved approximately $${estimatedSavings}. Visit the Benefits tab in your dashboard for detailed tracking and insights.`;
            } else {
                benefitsExtendedTextElement.textContent = 'Keep going! Your benefits will grow with each meal you skip. Visit the Benefits tab in your dashboard for detailed tracking.';
            }
        }

        function startTipRotation() {
            stopTipRotation(); // Clear any existing interval

            if (hungerCoach && isRunning) {
                tipRotationInterval = setInterval(async () => {
                    await updateHungerCard();
                }, TIP_ROTATION_INTERVAL);
            }
        }

        function stopTipRotation() {
            if (tipRotationInterval) {
                clearInterval(tipRotationInterval);
                tipRotationInterval = null;
            }
        }

        // User mealtimes cache
        let userMealtimes = null;
        let mealtimesLoaded = false;

        async function getUserMealtimes() {
            // Return cached mealtimes if already loaded
            if (mealtimesLoaded && userMealtimes) {
                return userMealtimes;
            }

            const sessionId = window.getSessionId();
            if (!sessionId) {
                // Return defaults if no session
                const sessionDefaults = {
                    breakfast: '08:00',
                    lunch: '12:00',
                    dinner: '18:00'
                };
                userMealtimes = sessionDefaults;
                mealtimesLoaded = true;
                return sessionDefaults;
            }

            try {
                const response = await fetch(`/api/user/${sessionId}/hunger-settings`);
                if (response.ok) {
                    const settings = await response.json();

                    // Convert custom_mealtimes array to object format expected by HungerCoach
                    let settingsMealtimes = {};
                    if (settings.custom_mealtimes && Array.isArray(settings.custom_mealtimes)) {
                        settings.custom_mealtimes.forEach(meal => {
                            // Use meal name as key, but convert to lowercase for consistency
                            const key = meal.name.toLowerCase().replace(/\s+/g, '_');
                            settingsMealtimes[key] = meal.time;
                        });
                    }

                    // Fallback to defaults if no custom mealtimes
                    if (Object.keys(settingsMealtimes).length === 0) {
                        settingsMealtimes = {
                            breakfast: '08:00',
                            lunch: '12:00',
                            dinner: '18:00'
                        };
                    }

                    mealtimesLoaded = true;
                    return settingsMealtimes;
                } else {
                    console.error('Failed to load user mealtimes:', response.status);
                    // Return defaults on failure
                    const fallbackDefaults = {
                        breakfast: '08:00',
                        lunch: '12:00',
                        dinner: '18:00'
                    };
                    userMealtimes = fallbackDefaults;
                    mealtimesLoaded = true;
                    return fallbackDefaults;
                }
            } catch (error) {
                console.error('Error loading user mealtimes:', error);
                // Return defaults on error
                const errorDefaults = {
                    breakfast: '08:00',
                    lunch: '12:00',
                    dinner: '18:00'
                };
                userMealtimes = errorDefaults;
                mealtimesLoaded = true;
                return errorDefaults;
            }
        }

        // Create milestone markers on the outer ring with responsive positioning
        function createMilestoneMarkers() {
            const container = document.getElementById('milestoneMarkers');
            // Clear any existing markers first
            container.innerHTML = '';
            
            // Get the actual current size of the circular timer
            const timerSize = Math.min(280, window.innerWidth * 0.7); // matches min(280px, 70vw)
            const containerRadius = timerSize / 2; // Full container radius
            const progressRingRadius = (timerSize - 20) / 2; // Actual progress ring radius
            
            milestones.forEach(milestone => {
                // Only show milestones that are within the fast duration
                if (milestone.hours <= fastDuration) {
                    const marker = document.createElement('div');
                    marker.className = 'milestone-marker';
                    marker.dataset.hours = milestone.hours;
                    
                    // Calculate position on outer progress ring (12 o'clock = 0°, clockwise)
                    const angle = (milestone.hours / fastDuration) * 360 - 90; // -90 to start at top
                    const radians = (angle * Math.PI) / 180;
                    // Position exactly on the outer progress ring
                    const x = containerRadius + progressRingRadius * Math.cos(radians);
                    const y = containerRadius + progressRingRadius * Math.sin(radians);
                    
                    marker.style.left = x + 'px';
                    marker.style.top = y + 'px';
                    
                    // Add tooltip
                    const tooltip = document.createElement('div');
                    tooltip.className = 'milestone-tooltip';
                    tooltip.innerHTML = `<strong>${milestone.icon} ${milestone.title}</strong><br>${milestone.message}`;
                    
                    // Add click handler to marker
                    marker.addEventListener('click', (e) => {
                        e.stopPropagation();
                        tooltip.classList.add('show');
                        document.body.appendChild(tooltip);
                    });
                    
                    // Add click handler to close tooltip
                    tooltip.addEventListener('click', (e) => {
                        e.stopPropagation();
                        tooltip.classList.remove('show');
                    });
                    
                    // Close tooltip when clicking outside
                    document.addEventListener('click', () => {
                        tooltip.classList.remove('show');
                    });
                    
                    marker.appendChild(tooltip);
                    
                    container.appendChild(marker);
                }
            });
        }
        
        // Track the last reached milestone to avoid repeated updates
        let lastReachedMilestone = null;
        
        // Update milestone states based on current progress
        function updateMilestoneStates() {
            const currentElapsedHours = elapsedTime / (1000 * 60 * 60);
            let currentMilestone = null;
            
            document.querySelectorAll('.milestone-marker').forEach(marker => {
                const milestoneHours = parseFloat(marker.dataset.hours);
                marker.classList.remove('reached', 'current');
                
                if (currentElapsedHours >= milestoneHours + 1) {
                    // Milestone completed (1 hour grace period)
                    marker.classList.add('reached');
                } else if (currentElapsedHours >= milestoneHours - 1 && currentElapsedHours < milestoneHours + 1) {
                    // Currently approaching or in milestone window
                    marker.classList.add('current');
                }
                
                // Check if we just reached this milestone
                if (currentElapsedHours >= milestoneHours && currentElapsedHours < milestoneHours + 1) {
                    // Find the milestone data
                    const milestone = milestones.find(m => m.hours === milestoneHours);
                    if (milestone) {
                        currentMilestone = milestone;
                    }
                }
            });
            
            // If we have a current milestone and it's different from the last one, update the display
            if (currentMilestone && currentMilestone !== lastReachedMilestone) {
                lastReachedMilestone = currentMilestone;
                updatePhaseInfoWithMilestone(currentMilestone);
            } else if (!currentMilestone && lastReachedMilestone) {
                // No current milestone, return to regular phase info
                lastReachedMilestone = null;
                const phaseElapsedHours = Math.floor(elapsedTime / (1000 * 60 * 60));
                updatePhaseInfo(phaseElapsedHours);
            } else if (!currentMilestone && !lastReachedMilestone) {
                // No milestone active, show regular phase info
                const regularPhaseHours = Math.floor(elapsedTime / (1000 * 60 * 60));
                updatePhaseInfo(regularPhaseHours);
            }
        }
        // Toggle duration selector visibility
        function toggleDurationSelector() {
            const selector = document.getElementById('durationSelector');
            const isVisible = selector.style.display !== 'none';
            
            if (isVisible) {
                selector.style.display = 'none';
            } else {
                selector.style.display = 'block';
            }
            
            // Update sticky button visibility when selector is toggled
            setTimeout(updateStickyButtonVisibility, 50); // Small delay to let display change take effect
        }
        
        // Select a preset duration
        function selectDuration(hours) {
            selectedDuration = hours;
            
            // Update active state on buttons
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.classList.remove('active', 'selected-confirmation');
            });
            const selectedBtn = document.querySelector(`[data-hours="${hours}"]`);
            selectedBtn.classList.add('active');
            
            // Add confirmation animation
            selectedBtn.classList.add('selected-confirmation');
            setTimeout(() => {
                selectedBtn.classList.remove('selected-confirmation');
            }, 1200); // Remove after 1.2 seconds
            
            // Clear custom input
            document.getElementById('customHours').value = '';
            
            // Update start button text
            updateStartButtonText();
            
            // Update sticky button visibility
            updateStickyButtonVisibility();
        }
        
        // Apply custom duration
        function applyCustomDuration() {
            const customInput = document.getElementById('customHours');
            const customHours = parseInt(customInput.value);
            
            // Validation
            if (isNaN(customHours) || customHours < 1 || customHours > 168) {
                alert('Please enter a valid duration between 1 and 168 hours.');
                return;
            }
            
            selectedDuration = customHours;
            
            // Remove active state from preset buttons
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Update start button text
            updateStartButtonText();
            
            // Update sticky button visibility
            updateStickyButtonVisibility();
        }
        
        // Toggle start time inputs visibility
        function toggleStartTimeInputs() {
            const startTimeRadios = document.querySelectorAll('input[name="startTime"]');
            const timeInputGroup = document.getElementById('timeInputGroup');
            const isCustomTime = Array.from(startTimeRadios).find(r => r.checked)?.value === 'custom';
            
            if (isCustomTime) {
                timeInputGroup.style.display = 'flex';
                // Set default to current time if not already set
                const startTimeInput = document.getElementById('startTimeInput');
                if (!startTimeInput.value) {
                    const currentTime = new Date();
                    startTimeInput.value = currentTime.toTimeString().slice(0, 5); // HH:MM format
                }
            } else {
                timeInputGroup.style.display = 'none';
                selectedStartTime = null;
            }
            
            updateSelectedStartTime();
            updateStartButtonText();
        }
        
        // Update selected start time based on inputs
        function updateSelectedStartTime() {
            const modeRadios = document.querySelectorAll('input[name="startTime"]');
            const selectedMode = Array.from(modeRadios).find(r => r.checked)?.value;
            
            if (selectedMode === 'now') {
                selectedStartTime = null;
            } else if (selectedMode === 'custom') {
                const customTimeInput = document.getElementById('startTimeInput');
                const dateOffset = parseInt(document.getElementById('startDateOffset').value);
                
                if (customTimeInput.value) {
                    const nowTime = new Date();
                    const [hours, minutes] = customTimeInput.value.split(':').map(Number);
                    
                    // Create date with selected time
                    const selectedDate = new Date(nowTime);
                    selectedDate.setHours(hours, minutes, 0, 0);
                    
                    // Apply date offset (0 = today, 1 = yesterday)
                    selectedDate.setDate(selectedDate.getDate() - dateOffset);
                    
                    // Validate - can't be in the future or more than 7 days ago
                    const maxBackdate = new Date(nowTime.getTime() - (7 * 24 * 60 * 60 * 1000)); // 7 days ago
                    
                    if (selectedDate > nowTime) {
                        selectedStartTime = null;
                        alert('Start time cannot be in the future!');
                        customTimeInput.value = '';
                    } else if (selectedDate < maxBackdate) {
                        selectedStartTime = null;
                        alert('Start time cannot be more than 7 days ago!');
                        customTimeInput.value = '';
                    } else {
                        selectedStartTime = selectedDate;
                    }
                }
            }
        }
        
        // Update start button text based on selected duration and start time
        function updateStartButtonText() {
            const btn = document.getElementById('startFastBtn');
            const stickyBtn = document.getElementById('stickyStartBtn');
            const stickyBtnText = document.getElementById('stickyBtnText');
            const stickyBtnBadge = document.getElementById('stickyBtnBadge');
            
            if (selectedStartTime) {
                const startTimeStr = selectedStartTime.toLocaleTimeString('en-US', {
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true
                });
                btn.textContent = `Resume ${selectedDuration}h Fast (started ${startTimeStr})`;
                stickyBtnText.textContent = `Resume ${selectedDuration}h Fast`;
                stickyBtnBadge.textContent = `Started: ${startTimeStr}`;
            } else {
                btn.textContent = `Start ${selectedDuration}h Fast`;
                stickyBtnText.textContent = `Start ${selectedDuration}h Fast`;
                stickyBtnBadge.textContent = `Selected: ${selectedDuration} hours`;
            }
        }
        
        // Update sticky button visibility based on scroll position and duration selection
        function updateStickyButtonVisibility() {
            const mainButton = document.getElementById('startFastBtn');
            const stickyButton = document.getElementById('stickyStartBtn');
            const durationSelector = document.getElementById('durationSelector');
            
            // Only show sticky button if:
            // 1. Duration selector is visible (user is customizing)
            // 2. A preset duration was selected (not default 24h)
            // 3. Main button is not visible in viewport
            
            if (!mainButton || !stickyButton || !durationSelector) return;
            
            const mainButtonRect = mainButton.getBoundingClientRect();
            const isMainButtonVisible = mainButtonRect.top >= 0 && mainButtonRect.bottom <= window.innerHeight;
            const isDurationSelectorVisible = durationSelector.style.display !== 'none';
            const hasCustomDuration = selectedDuration !== 24 || selectedStartTime !== null;
            
            // Show sticky button when main button is not visible AND user has made a selection
            if (!isMainButtonVisible && isDurationSelectorVisible && hasCustomDuration) {
                stickyButton.style.display = 'block';
            } else {
                stickyButton.style.display = 'none';
            }
        }
        
        // Toggle start time adjustment controls
        function toggleStartTimeAdjustment() {
            const toggleAdjustmentRow = document.getElementById('startTimeAdjustment');
            const toggleAdjustBtn = document.getElementById('adjustStartBtn');
            
            if (toggleAdjustmentRow.style.display === 'none') {
                // Show adjustment controls
                toggleAdjustmentRow.style.display = 'block';
                toggleAdjustBtn.textContent = 'cancel';
                
                // Pre-populate with current start time
                const toggleTimeInput = document.getElementById('adjustTimeInput');
                const toggleDateOffset = document.getElementById('adjustDateOffset');
                
                toggleTimeInput.value = fastStartTime.toTimeString().slice(0, 5); // HH:MM
                
                // Calculate date offset
                const adjustToday = new Date();
                adjustToday.setHours(0, 0, 0, 0);
                const startDate = new Date(fastStartTime);
                startDate.setHours(0, 0, 0, 0);
                const daysDiff = Math.floor((adjustToday - startDate) / (24 * 60 * 60 * 1000));
                
                toggleDateOffset.value = Math.min(daysDiff, 2); // Cap at 2 days ago
            } else {
                // Hide adjustment controls
                cancelStartTimeAdjustment();
            }
        }
        
        // Apply start time adjustment
        async function applyStartTimeAdjustment() {
            const adjustTimeInput = document.getElementById('adjustTimeInput');
            const adjustDateOffset = document.getElementById('adjustDateOffset');

            if (!adjustTimeInput.value) {
                alert('Please enter a start time.');
                return;
            }

            // Calculate new start time
            const adjustmentTime = new Date();
            const [hours, minutes] = adjustTimeInput.value.split(':').map(Number);
            const adjustmentDateOffset = parseInt(adjustDateOffset.value);

            const newStartTime = new Date(adjustmentTime);
            newStartTime.setHours(hours, minutes, 0, 0);
            newStartTime.setDate(newStartTime.getDate() - adjustmentDateOffset);

            // Validation
            const adjustmentMaxBackdate = new Date(adjustmentTime.getTime() - (7 * 24 * 60 * 60 * 1000));

            if (newStartTime > adjustmentTime) {
                alert('Start time cannot be in the future!');
                return;
            } else if (newStartTime < adjustmentMaxBackdate) {
                alert('Start time cannot be more than 7 days ago!');
                return;
            }

            // Update the fast start time
            fastStartTime = newStartTime;
            elapsedTime = Date.now() - fastStartTime.getTime();

            // 1. Update database record
            if (currentFastId) {
                try {
                    const updateResponse = await fetch(`/api/fasts/${currentFastId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ start_time: fastStartTime.toISOString() })
                    });

                    if (!updateResponse.ok) {
                        console.error('Failed to update fast start time in database');
                    }
                } catch (error) {
                    console.error('Error updating fast start time:', error);
                }
            }

            // 2. Save updated timer state to localStorage
            const adjustedTimerState = {
                fastStartTime: fastStartTime.toISOString(),
                fastDuration: fastDuration,
                isActive: true,
                currentFastId: currentFastId
            };
            localStorage.setItem('fastingForecast_timerState', JSON.stringify(adjustedTimerState));

            // 3. Restart notifications with new start time
            if (globalNotificationManager) {
                try {
                    globalNotificationManager.stopNotificationsForFast();
                    await globalNotificationManager.startNotificationsForFast(fastStartTime, fastDuration);
                } catch (error) {
                    console.error('Error updating notifications:', error);
                }
            }

            // 4. Update contextual cards with new elapsed time
            if (cardRotationManager) {
                try {
                    // Card rotation manager handles its own updates automatically
                    // Just ensure fast state is current
                    const cardMealtimes = await getUserMealtimes();
                    cardRotationManager.updateFastState(isRunning, fastStartTime, cardMealtimes);
                } catch (error) {
                    console.error('Error updating contextual cards:', error);
                }
            } else if (hungerCoach) {
                // Fallback to legacy hunger coach update
                try {
                    await updateHungerCard();
                } catch (error) {
                    console.error('Error updating hunger coach:', error);
                }
            }

            // 5. Update UI displays
            updateTimeDisplay();
            updateTimerDisplay();

            // 6. Update milestone states based on new elapsed time
            updateMilestoneStates();

            // Hide adjustment controls
            cancelStartTimeAdjustment();
        }
        
        // Cancel start time adjustment
        function cancelStartTimeAdjustment() {
            const cancelAdjustmentRow = document.getElementById('startTimeAdjustment');
            const cancelAdjustBtn = document.getElementById('adjustStartBtn');
            
            cancelAdjustmentRow.style.display = 'none';
            cancelAdjustBtn.innerHTML = '<small>adjust</small>';
        }
        
        // Start a fast
        async function startFast() {
            // Use selected duration for this fast
            fastDuration = selectedDuration;
            
            // Hide duration selector
            document.getElementById('durationSelector').style.display = 'none';
            
            document.getElementById('preFastState').style.display = 'none';
            document.getElementById('activeFastState').style.display = 'block';
            document.querySelector('.welcome-message').style.display = 'none';
            
            isRunning = true;
            // Always use current time for "Start now", enforce selected time for custom start
            if (selectedStartTime) {
                fastStartTime = selectedStartTime;
                elapsedTime = Date.now() - selectedStartTime.getTime();
                console.log('Starting fast with custom start time:', fastStartTime);
            } else {
                fastStartTime = new Date();
                elapsedTime = 0;
                console.log('Starting fast now at:', fastStartTime);
            }
            
            // Create fast entry in database
            await createFastEntry();
            
            // Save timer state to localStorage for persistence across navigation
            const newTimerState = {
                isRunning: true,
                fastStartTime: fastStartTime.toISOString(),
                fastDuration: fastDuration,
                currentFastId: currentFastId
            };
            localStorage.setItem('fastingForecast_timerState', JSON.stringify(newTimerState));
            
            // Create milestone markers
            createMilestoneMarkers();

            // Initialize and show contextual cards
            if (!cardRotationManager) {
                await initializeCardRotationManager();
            }
            await showContextualCards();

            // Start global notifications for the fast
            if (globalNotificationManager) {
                await globalNotificationManager.startNotificationsForFast(fastStartTime, fastDuration);
            }
            
            // Set start and end times
            updateTimeDisplay();
            
            // Initial display update
            updateTimerDisplay();
            
            // If backdated, immediately update milestone states to reflect elapsed time
            if (selectedStartTime) {
                updateMilestoneStates();
            }
            
            // Start the timer interval
            console.log('Starting timer interval - fastStartTime:', fastStartTime);
            timerInterval = setInterval(() => {
                const newElapsedTime = Date.now() - fastStartTime.getTime();
                console.log('Timer tick - elapsed:', Math.round(newElapsedTime/1000), 'seconds');
                elapsedTime = newElapsedTime;
                updateTimerDisplay();
            }, 1000);
        }
        
        // End a fast
        async function endFast() {
            if (isRunning) {
                clearInterval(timerInterval);
                isRunning = false;

                // Hide contextual cards and stop global notifications
                hideContextualCards();
                if (globalNotificationManager) {
                    globalNotificationManager.stopNotificationsForFast();
                }

                // End fast entry in database
                await endFastEntry();

                // Clear timer state from localStorage
                localStorage.removeItem('fastingForecast_timerState');
            }
            
            // Show completion state instead of going back to pre-fast
            showFastCompletion();
        }
        
        // Update timer display with elapsed/remaining logic
        function updateTimerDisplay() {
            console.log('updateTimerDisplay called - elapsedTime:', elapsedTime, 'fastDuration:', fastDuration);
            const totalFastDuration = fastDuration * 60 * 60 * 1000; // Convert hours to milliseconds
            const remainingTime = Math.max(0, totalFastDuration - elapsedTime);
            const isShowingElapsed = elapsedTime <= totalFastDuration / 2;
            console.log('totalFastDuration:', totalFastDuration, 'remainingTime:', remainingTime, 'isShowingElapsed:', isShowingElapsed);
            const isPastOriginalGoal = elapsedTime > totalFastDuration;
            
            let displayTime, label;
            
            if (isPastOriginalGoal) {
                // Past original goal - always show total elapsed time
                displayTime = elapsedTime;
                label = 'EXTENDED FAST';
            } else if (isShowingElapsed) {
                displayTime = elapsedTime;
                label = 'ELAPSED';
            } else {
                displayTime = remainingTime;
                label = 'REMAINING';
            }
            
            const hours = Math.floor(displayTime / (1000 * 60 * 60));
            const minutes = Math.floor((displayTime % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((displayTime % (1000 * 60)) / 1000);
            
            // Show seconds for first hour, then switch to HH:MM
            const showSeconds = elapsedTime < (60 * 60 * 1000); // First 60 minutes
            
            const formattedTime = showSeconds
                ? `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`
                : `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;

            console.log('Setting timerDisplay to:', formattedTime);
            document.getElementById('timerDisplay').textContent = formattedTime;
            console.log('timerDisplay DOM element now shows:', document.getElementById('timerDisplay').textContent);
            
            document.getElementById('timerLabel').textContent = label;
            
            // Update triple-layer circular progress
            
            // Outer circle: Overall fast progress (24 hours)
            const overallProgressPercent = Math.min(100, (elapsedTime / totalFastDuration) * 100);
            const overallProgressDegrees = (overallProgressPercent / 100) * 360;
            document.getElementById('timerProgressOuter').style.background = 
                `conic-gradient(#ec4899 ${overallProgressDegrees}deg, #f0f0f0 ${overallProgressDegrees}deg)`;
            
            // Inner circle: Current hour progress (resets every hour)
            const millisecondsInHour = 60 * 60 * 1000;
            const currentHourProgress = (elapsedTime % millisecondsInHour) / millisecondsInHour;
            const hourProgressDegrees = currentHourProgress * 360;
            document.getElementById('timerProgressInner').style.background = 
                `conic-gradient(#fb923c ${hourProgressDegrees}deg, #f8f9fa ${hourProgressDegrees}deg)`;
            
            // Innermost circle: First minute and last minute logic
            const minuteElement = document.getElementById('timerProgressMinute');
            const radarPulse = document.getElementById('radarPulse');
            const millisecondsInMinute = 60 * 1000;
            // Use the remainingTime already calculated above
            
            if (elapsedTime <= millisecondsInMinute) {
                // First minute: Show progress and fade out pulse
                const minuteProgress = elapsedTime / millisecondsInMinute;
                const minuteProgressDegrees = minuteProgress * 360;
                
                minuteElement.classList.add('visible');
                minuteElement.style.background = 
                    `conic-gradient(#fcd34d ${minuteProgressDegrees}deg, #f8f9fa ${minuteProgressDegrees}deg)`;
                
                // Show radar pulse with fade out intensity over the minute (strong to weak)
                // Use a slower fade curve: stays strong until 75% through, then fades to 30%
                const firstMinutePulseIntensity = minuteProgress < 0.75 ? 
                    1 - (minuteProgress * 0.3) :  // Slow fade from 1.0 to 0.7 over first 75%
                    0.7 - ((minuteProgress - 0.75) / 0.25) * 0.4; // Faster fade from 0.7 to 0.3 over last 25%
                
                radarPulse.classList.add('visible');
                radarPulse.style.setProperty('--pulse-opacity', Math.max(0.3, firstMinutePulseIntensity));
                
            } else if (remainingTime <= millisecondsInMinute && remainingTime > 0) {
                // Last minute: Show progress and fade in pulse
                const lastMinuteProgress = (millisecondsInMinute - remainingTime) / millisecondsInMinute;
                const lastMinuteProgressDegrees = lastMinuteProgress * 360;
                
                minuteElement.classList.add('visible');
                minuteElement.style.background = 
                    `conic-gradient(#fcd34d ${lastMinuteProgressDegrees}deg, #f8f9fa ${lastMinuteProgressDegrees}deg)`;
                
                // Show radar pulse with fade in intensity over the last minute (weak to strong)
                // Start at 30% and build to full intensity more gradually
                const lastMinutePulseIntensity = lastMinuteProgress < 0.25 ? 
                    0.3 + (lastMinuteProgress / 0.25) * 0.4 : // Slow build from 0.3 to 0.7 over first 25%
                    0.7 + ((lastMinuteProgress - 0.25) / 0.75) * 0.3; // Build from 0.7 to 1.0 over last 75%
                    
                radarPulse.classList.add('visible');
                radarPulse.style.setProperty('--pulse-opacity', Math.min(1.0, lastMinutePulseIntensity));
                
            } else {
                // Hide minute ring and pulse during middle period
                minuteElement.classList.remove('visible');
                radarPulse.classList.remove('visible');
            }
            
            // Update milestone states and phase info
            updateMilestoneStates();
        }
        
        // Update start and end time display
        function updateTimeDisplay() {
            if (!fastStartTime) return;

            console.log('updateTimeDisplay called with fastStartTime:', fastStartTime);
            console.log('fastStartTime UTC string:', fastStartTime.toISOString());
            console.log('fastStartTime local string:', fastStartTime.toString());

            const displayStartTime = fastStartTime;
            const displayEndTime = new Date(fastStartTime.getTime() + (fastDuration * 60 * 60 * 1000));
            
            const formatDateTime = (date) => {
                const timeStr = date.toLocaleTimeString('en-US', { 
                    hour: 'numeric', 
                    minute: '2-digit',
                    hour12: true 
                });
                
                // Check if it's a different day to show date
                const today = new Date();
                const isToday = date.toDateString() === today.toDateString();
                const isTomorrow = date.toDateString() === new Date(today.getTime() + 24 * 60 * 60 * 1000).toDateString();
                
                if (isToday) {
                    return timeStr + ' (Today)';
                } else if (isTomorrow) {
                    return timeStr + ' (Tomorrow)';
                } else {
                    // Show abbreviated date for other days
                    const dateStr = date.toLocaleDateString('en-US', { 
                        month: 'short', 
                        day: 'numeric' 
                    });
                    return timeStr + ' (' + dateStr + ')';
                }
            };
            
            const formattedStartTime = formatDateTime(displayStartTime);
            const formattedEndTime = formatDateTime(displayEndTime);

            console.log('Setting start time display to:', formattedStartTime);
            console.log('Setting end time display to:', formattedEndTime);

            document.getElementById('startTime').textContent = formattedStartTime;
            document.getElementById('endTime').textContent = formattedEndTime;

            console.log('DOM startTime element now shows:', document.getElementById('startTime').textContent);
        }
        
        // Update phase information based on elapsed hours
        function updatePhaseInfo(hours) {
            let currentPhase = phases[0];
            
            // Find the appropriate phase
            for (const phaseHour in phases) {
                if (hours >= parseInt(phaseHour)) {
                    currentPhase = phases[phaseHour];
                }
            }
            
            document.getElementById('phaseTitle').textContent = currentPhase.title;
            document.getElementById('phaseDescription').textContent = currentPhase.description;
        }
        
        // Update phase info container with milestone details
        function updatePhaseInfoWithMilestone(milestone) {
            document.getElementById('phaseTitle').textContent = `${milestone.icon} ${milestone.title}`;
            document.getElementById('phaseDescription').textContent = milestone.message;
        }
        
        
        
        // Reset timer
        function resetTimer() {
            if (isRunning) {
                clearInterval(timerInterval);
                isRunning = false;
            }
            
            // Clear milestone markers
            document.getElementById('milestoneMarkers').innerHTML = '';
            
            // Reset milestone tracking
            lastReachedMilestone = null;
            
            // Reset start time selection
            selectedStartTime = null;
            document.querySelector('input[name="startTime"][value="now"]').checked = true;
            document.getElementById('timeInputGroup').style.display = 'none';
            document.getElementById('startTimeInput').value = '';
            
            // Hide adjustment controls
            cancelStartTimeAdjustment();
            
            // Hide duration selector
            document.getElementById('durationSelector').style.display = 'none';
            
            // Reset to pre-fast state
            document.getElementById('activeFastState').style.display = 'none';
            document.getElementById('preFastState').style.display = 'block';
            document.querySelector('.welcome-message').style.display = 'block';
            
            elapsedTime = 0;
            fastStartTime = null;
            
            // Clear timer state from localStorage
            localStorage.removeItem('fastingForecast_timerState');
        }
        
        // Load saved stats from API
        async function loadStats() {
            try {
                const loadStatsSessionId = window.getSessionId();
                if (!loadStatsSessionId) {
                    document.getElementById('totalFasts').textContent = '0';
                    document.getElementById('longestFast').textContent = '0h';
                    return;
                }
                
                // Fetch all completed fasts for this user
                const statsResponse = await fetch(`/api/fasts?sessionId=${loadStatsSessionId}&limit=1000`);
                if (statsResponse.ok) {
                    const statsFasts = await statsResponse.json();
                    
                    // Filter for completed fasts only (those with end_time)
                    const completedFasts = statsFasts.filter(fast => fast.end_time);
                    
                    // Calculate total completed fasts
                    const totalFasts = completedFasts.length;
                    document.getElementById('totalFasts').textContent = totalFasts.toString();
                    
                    // Calculate longest fast duration
                    let longestDuration = 0;
                    completedFasts.forEach(fast => {
                        let duration = 0;
                        
                        // Use stored duration_hours if available, otherwise calculate it
                        if (fast.duration_hours && fast.duration_hours > 0) {
                            duration = fast.duration_hours;
                        } else if (fast.start_time && fast.end_time) {
                            // Fallback calculation if duration_hours is missing or zero
                            const fastRecordStartTime = new Date(fast.start_time);
                            const fastEndTime = new Date(fast.end_time);
                            duration = (fastEndTime - fastRecordStartTime) / (1000 * 60 * 60); // Convert to hours
                        }
                        
                        if (duration > longestDuration) {
                            longestDuration = duration;
                        }
                    });
                    
                    // Format longest duration for display
                    let longestDisplayText = '0h';
                    if (longestDuration > 0) {
                        const days = Math.floor(longestDuration / 24);
                        const remainingHours = Math.floor(longestDuration % 24);
                        
                        if (days > 0) {
                            longestDisplayText = days === 1 ? '1 day' : `${days} days`;
                            if (remainingHours > 0) {
                                longestDisplayText += ` ${remainingHours}h`;
                            }
                        } else {
                            longestDisplayText = `${remainingHours}h`;
                        }
                    }
                    
                    document.getElementById('longestFast').textContent = longestDisplayText;
                } else {
                    // Fallback to defaults if API call fails
                    document.getElementById('totalFasts').textContent = '0';
                    document.getElementById('longestFast').textContent = '0h';
                }
            } catch (error) {
                console.error('Error loading stats:', error);
                // Fallback to defaults if there's an error
                document.getElementById('totalFasts').textContent = '0';
                document.getElementById('longestFast').textContent = '0h';
            }
        }
        
        // Initialize user state and determine what to show
        async function initializeUserState() {
            try {
                const initSessionId = window.getSessionId();
                
                if (initSessionId) {
                    // Check if user has any fasts in database
                    const initResponse = await fetch(`/api/fasts?sessionId=${initSessionId}&limit=1`);
                    if (initResponse.ok) {
                        const initFasts = await initResponse.json();
                        
                        if (initFasts.length === 0) {
                            // New user - show welcome state
                            showNewUserWelcome();
                        } else {
                            // User has completed fasts - check if they have actual scheduled fasts
                            await checkUserScheduleStatus(initSessionId);
                        }
                    } else {
                        // API error - default to new user welcome
                        showNewUserWelcome();
                    }
                } else {
                    // No session ID - definitely new user
                    showNewUserWelcome();
                }
            } catch (error) {
                console.error('Error checking user state:', error);
                // Default to new user welcome on error
                showNewUserWelcome();
            }
        }
        
        function showNewUserWelcome() {
            document.getElementById('newUserWelcome').style.display = 'block';
            document.getElementById('scheduleSetupState').style.display = 'none';
            document.getElementById('scheduledFastInfo').style.display = 'none';
            document.getElementById('newUserHint').style.display = 'block';
            
            // Show main start button
            document.getElementById('startFastBtn').style.display = 'block';
            
            // Update button text for new users
            document.getElementById('startFastBtn').textContent = 'Start Your First Fast';
        }
        
        function showScheduleSetupState() {
            document.getElementById('newUserWelcome').style.display = 'none';
            document.getElementById('scheduleSetupState').style.display = 'block';
            document.getElementById('scheduledFastInfo').style.display = 'none';
            document.getElementById('newUserHint').style.display = 'none';
            
            // Keep main start button visible as primary action
            document.getElementById('startFastBtn').style.display = 'block';
            document.getElementById('startFastBtn').textContent = 'Start Fast Now';
        }
        
        async function showScheduledFastState() {
            document.getElementById('newUserWelcome').style.display = 'none';
            document.getElementById('scheduleSetupState').style.display = 'none';
            document.getElementById('scheduledFastInfo').style.display = 'block';
            document.getElementById('newUserHint').style.display = 'none';

            // Show main start button
            document.getElementById('startFastBtn').style.display = 'block';

            // Update button text for users with schedules
            document.getElementById('startFastBtn').textContent = 'Start 24h Fast';

            // Load actual scheduled fast data
            await loadNextScheduledFast();
        }

        // Helper function to format relative date display
        function formatRelativeDate(targetDate) {
            const currentTimestamp = new Date();
            const todayDate = new Date(currentTimestamp.getFullYear(), currentTimestamp.getMonth(), currentTimestamp.getDate());
            const targetDateOnly = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate());

            const diffTime = targetDateOnly.getTime() - todayDate.getTime();
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

            const formattedTime = targetDate.toLocaleTimeString('en-US', {
                hour: 'numeric',
                minute: '2-digit',
                hour12: true
            });

            if (diffDays === 0) {
                return `Today at ${formattedTime}`;
            } else if (diffDays === 1) {
                return `Tomorrow at ${formattedTime}`;
            } else if (diffDays > 1 && diffDays <= 7) {
                const dayOfWeek = targetDate.toLocaleDateString('en-US', { weekday: 'long' });
                return `${dayOfWeek} at ${formattedTime}`;
            } else {
                const nextDayOfWeek = targetDate.toLocaleDateString('en-US', { weekday: 'long' });
                return `Next ${nextDayOfWeek} at ${formattedTime}`;
            }
        }

        // Load and display the next scheduled fast
        async function loadNextScheduledFast() {
            try {
                const upcomingScheduleResponse = await fetch(`/api/schedule/upcoming?sessionId=${globalSessionId}`);
                if (upcomingScheduleResponse.ok) {
                    const upcomingScheduleData = await upcomingScheduleResponse.json();
                    if (upcomingScheduleData.upcoming) {
                        const nextFast = upcomingScheduleData.upcoming;
                        const fastStartDate = new Date(nextFast.start_at_utc);
                        const fastEndDate = new Date(nextFast.end_at_utc);

                        // Use duration from API or calculate as fallback
                        const durationHours = nextFast.duration_hours || Math.round((fastEndDate.getTime() - fastStartDate.getTime()) / (1000 * 60 * 60));

                        // Format the display text
                        const relativeDate = formatRelativeDate(fastStartDate);
                        const durationText = durationHours === 24 ? '24-hour fast' : `${durationHours}-hour fast`;

                        document.getElementById('scheduledFastDetails').textContent = `${relativeDate} • ${durationText}`;
                    } else {
                        // No upcoming fasts found
                        document.getElementById('scheduledFastDetails').textContent = 'No upcoming fasts scheduled';
                    }
                } else {
                    console.error('Failed to fetch upcoming schedule');
                    // Set fallback text if API fails
                    document.getElementById('scheduledFastDetails').textContent = 'Schedule unavailable';
                }
            } catch (error) {
                console.error('Error loading next scheduled fast:', error);
                // Set fallback text if there's an error
                document.getElementById('scheduledFastDetails').textContent = 'Schedule unavailable';
            }
        }
        
        // Check user schedule status and show appropriate state
        async function checkUserScheduleStatus(sessionId) {
            try {
                const userScheduleResponse = await fetch(`/api/schedule?sessionId=${sessionId}`);
                if (userScheduleResponse.ok) {
                    const userScheduleData = await userScheduleResponse.json();
                    if (userScheduleData.schedule && userScheduleData.blocks && userScheduleData.blocks.length > 0) {
                        // User has a schedule with fasting blocks
                        await showScheduledFastState();
                    } else {
                        // User has no schedule or no fasting blocks - encourage setup
                        showScheduleSetupState();
                    }
                } else {
                    // API error - default to schedule setup
                    showScheduleSetupState();
                }
            } catch (error) {
                console.error('Error checking schedule status:', error);
                showScheduleSetupState();
            }
        }

        // Handle schedule setup button click
        function showScheduleSetup() {
            window.location.href = '/schedule';
        }
        
        // Confetti Animation
        function createConfetti() {
            const canvas = document.getElementById('confettiCanvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const confettiPieces = [];
            const colors = ['#fcd34d', '#fb923c', '#ec4899', '#28a745', '#20c997'];
            
            // Create confetti pieces
            for (let i = 0; i < 150; i++) {
                confettiPieces.push({
                    x: Math.random() * canvas.width,
                    y: -10,
                    dx: (Math.random() - 0.5) * 4,
                    dy: Math.random() * 3 + 2,
                    rotation: Math.random() * 360,
                    rotationSpeed: (Math.random() - 0.5) * 10,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    shape: Math.random() > 0.5 ? 'rectangle' : 'circle',
                    size: Math.random() * 6 + 4
                });
            }
            
            let animationFrame;
            
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                for (let j = confettiPieces.length - 1; j >= 0; j--) {
                    const piece = confettiPieces[j];
                    
                    // Update position
                    piece.x += piece.dx;
                    piece.y += piece.dy;
                    piece.rotation += piece.rotationSpeed;
                    
                    // Add gravity
                    piece.dy += 0.15;
                    
                    // Apply air resistance
                    piece.dx *= 0.99;
                    
                    // Draw piece
                    ctx.save();
                    ctx.translate(piece.x, piece.y);
                    ctx.rotate(piece.rotation * Math.PI / 180);
                    ctx.fillStyle = piece.color;
                    
                    if (piece.shape === 'circle') {
                        ctx.beginPath();
                        ctx.arc(0, 0, piece.size / 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.fillRect(-piece.size / 2, -piece.size / 2, piece.size, piece.size);
                    }
                    
                    ctx.restore();
                    
                    // Remove pieces that fall off screen
                    if (piece.y > canvas.height + 20) {
                        confettiPieces.splice(j, 1);
                    }
                }
                
                if (confettiPieces.length > 0) {
                    animationFrame = requestAnimationFrame(animate);
                } else {
                    // Hide canvas when animation is done
                    setTimeout(() => {
                        canvas.style.display = 'none';
                    }, 1000);
                }
            }
            
            canvas.style.display = 'block';
            animate();
        }
        
        // Calculate estimated calories burned during fasting
        function calculateCaloriesBurned(durationHours) {
            // Placeholder user profile (will be replaced with actual user data after onboarding)
            const userProfile = {
                weight: 160, // lbs
                bodyFatPercent: 25,
                activityLevel: 'sedentary' // sedentary, lightly_active, moderately_active, very_active, extremely_active
            };
            
            // Calculate lean body mass
            const weightKg = userProfile.weight * 0.453592;
            const leanBodyMassKg = weightKg * (1 - userProfile.bodyFatPercent / 100);
            
            // Calculate BMR using Katch-McArdle formula (based on lean body mass)
            const bmr = 370 + (21.6 * leanBodyMassKg);
            
            // Activity multipliers
            const activityMultipliers = {
                sedentary: 1.2,
                lightly_active: 1.375,
                moderately_active: 1.55,
                very_active: 1.725,
                extremely_active: 1.9
            };
            
            // Calculate TDEE
            const tdee = bmr * activityMultipliers[userProfile.activityLevel];
            const hourlyTdee = tdee / 24;
            
            // Apply fasting metabolic adjustments based on duration
            let totalCalories = 0;
            
            for (let hour = 0; hour < Math.ceil(durationHours); hour++) {
                let metabolicRate;
                
                if (hour < 12) {
                    metabolicRate = 0.95; // Minimal metabolic adaptation
                } else if (hour < 24) {
                    metabolicRate = 0.90; // Slight metabolic adaptation
                } else if (hour < 48) {
                    metabolicRate = 0.85; // Moderate metabolic adaptation
                } else {
                    metabolicRate = 0.80; // Significant metabolic adaptation
                }
                
                // For partial hours, calculate proportionally
                const hourFraction = hour < Math.floor(durationHours) ? 1 : (durationHours % 1);
                totalCalories += hourlyTdee * metabolicRate * hourFraction;
            }
            
            // Format with commas for readability
            return Math.round(totalCalories).toLocaleString();
        }
        
        // Get achieved milestones based on elapsed time
        function getAchievedMilestones(elapsedHours) {
            return milestones.filter(milestone => elapsedHours >= milestone.hours);
        }
        
        // Show fast completion state
        function showFastCompletion() {
            // Calculate final stats
            const finalElapsedHours = elapsedTime / (1000 * 60 * 60);
            const achievedMilestones = getAchievedMilestones(finalElapsedHours);
            
            // Update completion display
            const completionHours = Math.floor(finalElapsedHours);
            const completionMinutes = Math.floor((finalElapsedHours % 1) * 60);
            document.getElementById('completionDuration').textContent = 
                `${completionHours}:${String(completionMinutes).padStart(2, '0')}`;
            
            // Update calories
            document.getElementById('completionCalories').textContent = 
                `~${calculateCaloriesBurned(finalElapsedHours)}`;
            
            // Update milestones
            const milestonesContainer = document.getElementById('completionMilestones');
            milestonesContainer.innerHTML = '';
            
            if (achievedMilestones.length === 0) {
                milestonesContainer.innerHTML = '<p style="color: #666; font-style: italic;">Complete your first 12-hour milestone to see achievements here!</p>';
            } else {
                achievedMilestones.forEach(milestone => {
                    const milestoneEl = document.createElement('div');
                    milestoneEl.className = 'milestone-item';
                    milestoneEl.innerHTML = `
                        <div class="icon">${milestone.icon}</div>
                        <div class="info">
                            <div class="title">${milestone.title}</div>
                            <div class="time">Achieved at ${milestone.hours}h</div>
                        </div>
                    `;
                    milestonesContainer.appendChild(milestoneEl);
                });
            }
            
            // Hide active state and show completion
            document.getElementById('activeFastState').style.display = 'none';
            document.getElementById('completionState').style.display = 'block';
            
            // Trigger confetti animation
            createConfetti();
        }
        
        // Handle refeed notes CTA (placeholder)
        function openRefeedNotes() {
            // Placeholder - would open a modal or navigate to notes page
            alert('Refeed notes feature coming soon! 📝\n\nThis would allow you to log:\n• How you feel post-fast\n• Refeeding meal details\n• Energy levels\n• Any insights or observations');
        }
        
        // Start a new fast from completion screen
        function startNewFast() {
            // Hide completion state
            document.getElementById('completionState').style.display = 'none';
            
            // Reset all timer state
            if (isRunning) {
                clearInterval(timerInterval);
                isRunning = false;
            }
            
            // Clear milestone markers
            document.getElementById('milestoneMarkers').innerHTML = '';
            
            // Reset milestone tracking
            lastReachedMilestone = null;
            
            // Reset start time selection
            selectedStartTime = null;
            document.querySelector('input[name="startTime"][value="now"]').checked = true;
            document.getElementById('timeInputGroup').style.display = 'none';
            document.getElementById('startTimeInput').value = '';
            
            // Hide adjustment controls
            cancelStartTimeAdjustment();
            
            // Hide duration selector
            document.getElementById('durationSelector').style.display = 'none';
            
            // Show pre-fast state
            document.getElementById('preFastState').style.display = 'block';
            
            elapsedTime = 0;
            fastStartTime = null;
            
            // Update button text
            updateStartButtonText();
        }
        
        // Note: Timer now continues indefinitely until user manually ends the fast
        // The checkFastCompletion() function has been removed to allow fasting beyond planned duration
        
        // Initialize
        loadStats(); // Async call - no need to await in initialization
        
        // Bottom Navigation Functionality
        function updateActiveNavItem() {
            const currentPath = window.location.pathname;
            const navItems = document.querySelectorAll('.nav-item');
            
            navItems.forEach(item => {
                item.classList.remove('active');
                const href = item.getAttribute('href');
                
                // Set active state based on current path
                if (href === currentPath || (href === '/timer' && (currentPath === '/timer' || currentPath === '/timer.html'))) {
                    item.classList.add('active');
                }
            });
        }
        
        // Update navigation on page load
        document.addEventListener('DOMContentLoaded', () => {
            updateActiveNavItem();
            initializeUserState();
            
            // Add click handlers for navigation items
            const clickNavItems = document.querySelectorAll('.nav-item');
            clickNavItems.forEach(item => {
                item.addEventListener('click', (e) => {
                    const clickHref = item.getAttribute('href');
                    
                    // For now, prevent default navigation for pages that don't exist
                    if (clickHref !== '/dashboard' && clickHref !== '/timer' && clickHref !== '/schedule' && clickHref !== '/settings') {
                        e.preventDefault();
                        
                        // Show a temporary message for unimplemented pages
                        const pageName = item.querySelector('.nav-label').textContent;
                        alert(`${pageName} page coming soon!`);
                    }
                });
            });
            
            // Add resize handler to recalculate milestone positions
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    // Only recalculate if milestones are currently visible
                    if (document.getElementById('milestoneMarkers').children.length > 0) {
                        createMilestoneMarkers();
                    }
                }, 150); // Debounce resize events
            });
            
            // Add scroll event listener for sticky button
            let scrollTimeout;
            window.addEventListener('scroll', () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    updateStickyButtonVisibility();
                }, 10); // Debounce scroll events
            });
        });
        
        // Update active nav item when navigating (for SPA-style navigation in the future)
        window.addEventListener('popstate', updateActiveNavItem);
        
        // Database integration functions
        async function createFastEntry() {
            try {
                // Get session ID to link fast to user profile
                const createSessionId = window.getSessionId();
                console.log('Creating fast entry with sessionId:', createSessionId);
                
                const fastData = {
                    start_time: fastStartTime.toISOString(),
                    notes: null,
                    weight: null,
                    is_manual: false,
                    sessionId: createSessionId
                };
                
                console.log('Sending fast data:', fastData);
                
                const createResponse = await fetch('/api/fasts/start', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(fastData)
                });
                
                if (createResponse.ok) {
                    const createdFast = await createResponse.json();
                    currentFastId = createdFast.id;
                    console.log('Fast entry created:', createdFast);
                } else {
                    console.error('Failed to create fast entry');
                }
            } catch (error) {
                console.error('Error creating fast entry:', error);
            }
        }
        
        async function endFastEntry() {
            if (!currentFastId) return;
            
            try {
                const endTimeISO = new Date().toISOString();
                
                const endResponse = await fetch(`/api/fasts/${currentFastId}/end`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ end_time: endTimeISO })
                });
                
                if (endResponse.ok) {
                    const completedFast = await endResponse.json();
                    console.log('Fast entry completed:', completedFast);
                    currentFastId = null;
                    
                    // Update stats display after completing a fast
                    loadStats();
                } else {
                    console.error('Failed to end fast entry');
                }
            } catch (error) {
                console.error('Error ending fast entry:', error);
            }
        }

        // Reset to initial state - clean slate
        function resetToInitialState() {
            // Stop any running timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // Reset all timer variables
            isRunning = false;
            fastStartTime = null;
            elapsedTime = 0;
            currentFastId = null;

            // Reset start time selection
            selectedStartTime = null;
            if (document.querySelector('input[name="startTime"][value="now"]')) {
                document.querySelector('input[name="startTime"][value="now"]').checked = true;
            }

            // Show pre-fast state, hide active fast state
            document.getElementById('preFastState').style.display = 'block';
            document.getElementById('activeFastState').style.display = 'none';
            document.querySelector('.welcome-message').style.display = 'block';

            // Clear any adjustment controls
            const adjustmentRow = document.getElementById('startTimeAdjustment');
            if (adjustmentRow) {
                adjustmentRow.style.display = 'none';
            }

            console.log('Reset to initial state - ready for fresh fast start');
        }

        // Check for active fast on page load
        async function checkForActiveFast() {
            try {
                console.log('🔍 checkForActiveFast started');

                // First check if we have timer state in localStorage
                const savedTimerState = localStorage.getItem('fastingForecast_timerState');
                console.log('🔍 localStorage timer state:', savedTimerState ? 'exists' : 'empty');

                // Get session ID for user-specific active fast check
                const checkSessionId = window.getSessionId();
                console.log('🔍 Session ID for fast check:', checkSessionId);
                if (!checkSessionId) {
                    console.log('No session ID found, cannot check for active fast');
                    // Clear any stale localStorage if no session
                    if (savedTimerState) {
                        console.log('Clearing stale timer state - no session ID');
                        localStorage.removeItem('fastingForecast_timerState');
                    }
                    return;
                }

                console.log('🔍 Making API call to /api/fasts/active');
                const activeResponse = await fetch(`/api/fasts/active?sessionId=${checkSessionId}`);
                console.log('🔍 API response status:', activeResponse.status);

                if (activeResponse.ok) {
                    const activeFast = await activeResponse.json();
                    console.log('🔍 Active fast from API:', activeFast);

                    if (activeFast && savedTimerState) {
                        // Restore timer state if both database and localStorage indicate active fast
                        await restoreTimerState(savedTimerState, activeFast);
                    } else if (!activeFast && savedTimerState) {
                        // Clear stale localStorage if database shows no active fast
                        console.log('Clearing stale timer state from localStorage - no active fast in database');
                        localStorage.removeItem('fastingForecast_timerState');
                        // Ensure we're in the correct initial state
                        resetToInitialState();
                    } else if (activeFast && !savedTimerState) {
                        try {
                            // Database has active fast but no localStorage state - restore the timer
                            console.log('🚀 Found active fast but no localStorage state, restoring timer');
                            console.log('🚀 activeFast.id:', activeFast.id);
                            console.log('🚀 activeFast.start_time:', activeFast.start_time);

                        if (!activeFast.id || !activeFast.start_time) {
                            console.error('🚀 Invalid active fast object - missing id or start_time');
                            return;
                        }

                        console.log('🚀 Setting currentFastId to:', activeFast.id);
                        // Avoid scoping issues by using a local variable
                        const activeFastId = activeFast.id;

                        // Ensure proper date parsing from database UTC timestamp
                        const dbStartTime = activeFast.start_time;
                        console.log('🚀 Raw database start_time:', dbStartTime);
                        fastStartTime = new Date(dbStartTime);
                        console.log('🚀 Parsed fastStartTime:', fastStartTime, 'isValid:', !isNaN(fastStartTime.getTime()));

                        if (isNaN(fastStartTime.getTime())) {
                            console.error('🚀 Invalid start time could not be parsed');
                            return;
                        }

                        isRunning = true;
                        elapsedTime = Date.now() - fastStartTime.getTime();
                        console.log('🚀 Calculated elapsed time:', Math.round(elapsedTime / 1000), 'seconds');

                        console.log('🚀 About to show active fast UI and start timer...');

                        try {
                            // Show active fast UI
                            console.log('🚀 Setting UI display states...');
                            document.getElementById('preFastState').style.display = 'none';
                            document.getElementById('activeFastState').style.display = 'block';
                            document.querySelector('.welcome-message').style.display = 'none';
                            console.log('🚀 UI display states set successfully');
                        } catch (uiError) {
                            console.error('🚀 Error setting UI states:', uiError);
                        }

                        try {
                            // Set up timer display
                            console.log('🚀 Calling updateTimerDisplay...');
                            updateTimerDisplay();
                            console.log('🚀 updateTimerDisplay completed');
                        } catch (timerDisplayError) {
                            console.error('🚀 Error in updateTimerDisplay:', timerDisplayError);
                        }

                        try {
                            // Update start and end time display immediately
                            console.log('🚀 Calling updateTimeDisplay from timer setup...');
                            updateTimeDisplay();
                            console.log('🚀 updateTimeDisplay completed from timer setup');
                        } catch (timeDisplayError) {
                            console.error('🚀 Error in updateTimeDisplay:', timeDisplayError);
                        }

                        try {

                            // Start the timer interval
                            console.log('🚀 Starting timer interval from session restoration - fastStartTime:', fastStartTime);
                            timerInterval = setInterval(() => {
                                const newElapsedTime = Date.now() - fastStartTime.getTime();
                                console.log('Session restore timer tick - elapsed:', Math.round(newElapsedTime/1000), 'seconds');
                                elapsedTime = newElapsedTime;
                                updateTimerDisplay();
                            }, 1000);
                            console.log('🚀 Timer interval started successfully');

                            // Update start and end time display
                            console.log('🚀 Calling updateTimeDisplay...');
                            updateTimeDisplay();
                            console.log('🚀 updateTimeDisplay completed');

                        } catch (timerError) {
                            console.error('🚀 Error setting up timer:', timerError);
                        }

                        // Initialize cards and notifications
                        if (!cardRotationManager) {
                            await initializeCardRotationManager();
                        }
                        await showContextualCards();

                            if (globalNotificationManager) {
                                await globalNotificationManager.startNotificationsForFast(fastStartTime, 24); // Default 24h duration
                            }

                            // Set the global currentFastId only after everything else is successful
                            console.log('🚀 Setting global currentFastId at the end');
                            currentFastId = activeFastId;
                        } catch (restoreError) {
                            console.error('🚀 Error during timer restoration:', restoreError);
                            console.error('🚀 Error stack:', restoreError.stack);
                        }
                    }
                }
            } catch (error) {
                console.error('Error checking for active fast:', error);
            }
        }
        
        // Restore timer state from localStorage
        async function restoreTimerState(savedStateString, activeFast) {
            try {
                const savedState = JSON.parse(savedStateString);
                
                // Validate saved state matches database
                if (savedState.currentFastId !== activeFast.id) {
                    console.log('Saved timer state does not match active fast, clearing localStorage');
                    localStorage.removeItem('fastingForecast_timerState');
                    return;
                }
                
                // Restore timer variables
                currentFastId = savedState.currentFastId;

                // Ensure proper date parsing from localStorage
                const localStorageStartTime = savedState.fastStartTime;
                console.log('Raw localStorage fastStartTime:', localStorageStartTime);
                fastStartTime = new Date(localStorageStartTime);
                console.log('Parsed fastStartTime:', fastStartTime, 'isValid:', !isNaN(fastStartTime.getTime()));

                fastDuration = savedState.fastDuration;
                isRunning = true;

                // Calculate current elapsed time
                elapsedTime = Date.now() - fastStartTime.getTime();
                console.log('Calculated elapsed time:', Math.round(elapsedTime / 1000), 'seconds');
                
                console.log('Restoring timer state:', {
                    fastStartTime: fastStartTime,
                    fastDuration: fastDuration,
                    elapsedTime: Math.round(elapsedTime / 1000) + 's'
                });
                
                // Update UI to show active fast state
                document.getElementById('preFastState').style.display = 'none';
                document.getElementById('activeFastState').style.display = 'block';
                document.querySelector('.welcome-message').style.display = 'none';
                
                // Create milestone markers
                createMilestoneMarkers();

                // Initialize and show contextual cards
                if (!cardRotationManager) {
                    await initializeCardRotationManager();
                }
                await showContextualCards();

                // Resume global notifications for the fast
                if (globalNotificationManager) {
                    await globalNotificationManager.startNotificationsForFast(fastStartTime, fastDuration);
                }

                // Set start and end times
                updateTimeDisplay();
                
                // Update timer display immediately
                updateTimerDisplay();
                
                // Update milestone states based on elapsed time
                updateMilestoneStates();
                
                // Start the timer interval
                console.log('Starting timer interval from localStorage restoration - fastStartTime:', fastStartTime);
                timerInterval = setInterval(() => {
                    const newElapsedTime = Date.now() - fastStartTime.getTime();
                    console.log('localStorage restore timer tick - elapsed:', Math.round(newElapsedTime/1000), 'seconds');
                    elapsedTime = newElapsedTime;
                    updateTimerDisplay();
                }, 1000);
                
            } catch (error) {
                console.error('Error restoring timer state:', error);
                localStorage.removeItem('fastingForecast_timerState');
            }
        }
        
        // Check for upcoming scheduled fast
        async function checkForUpcomingFast() {
            try {
                // Check for upcoming fast
                const upcomingResponse = await fetch(`/api/schedule/upcoming?sessionId=${sessionId}`);
                if (upcomingResponse.ok) {
                    const upcomingData = await upcomingResponse.json();
                    if (upcomingData.upcoming) {
                        showUpcomingFast(upcomingData.upcoming);
                    }
                } else if (upcomingResponse.status === 404) {
                    // If user profile not found (database was reset), clear localStorage and redirect to onboarding
                    const upcomingErrorData = await upcomingResponse.json();
                    if (upcomingErrorData.error && upcomingErrorData.error.includes('User profile not found')) {
                        console.log('User profile missing after server restart - redirecting to onboarding');
                        localStorage.removeItem('fastingForecast_sessionId');
                        localStorage.removeItem('fastingForecast_profileSaved');
                        window.location.href = '/forecaster';
                        return;
                    }
                }
                
                // Check if user has a schedule and hide setup prompt if they do
                const scheduleResponse = await fetch(`/api/schedule?sessionId=${globalSessionId}`);
                if (scheduleResponse.ok) {
                    const scheduleData = await scheduleResponse.json();
                    const scheduleSetupElement = document.getElementById('scheduleSetupState');
                    if (scheduleSetupElement) {
                        if (scheduleData.schedule) {
                            // User has a schedule, hide the setup prompt
                            scheduleSetupElement.style.display = 'none';
                        } else {
                            // User doesn't have a schedule, show the setup prompt
                            scheduleSetupElement.style.display = 'block';
                        }
                    }
                } else if (scheduleResponse.status === 404) {
                    // If user profile not found (database was reset), clear localStorage and redirect to onboarding
                    const scheduleErrorData = await scheduleResponse.json();
                    if (scheduleErrorData.error && scheduleErrorData.error.includes('User profile not found')) {
                        console.log('User profile missing after server restart - redirecting to onboarding');
                        localStorage.removeItem('fastingForecast_sessionId');
                        localStorage.removeItem('fastingForecast_profileSaved');
                        window.location.href = '/forecaster';
                        return;
                    }
                }
            } catch (error) {
                console.error('Error checking for upcoming fast:', error);
            }
        }
        
        // Display upcoming fast information
        function showUpcomingFast(upcomingFast) {
            // Only show if no active timer (pre-timer page)
            if (isRunning) return;
            
            const upcomingStartTime = new Date(upcomingFast.start_at_utc);
            const now = new Date();
            const hoursUntil = Math.round((upcomingStartTime - now) / (1000 * 60 * 60));
            const isActionable = hoursUntil <= 6; // Within 6 hours = actionable with Start Early
            
            // Create upcoming fast display
            const upcomingDiv = document.getElementById('upcoming-fast-notice') || createUpcomingNotice();
            
            const dayName = upcomingStartTime.toLocaleDateString('en-US', { weekday: 'short' });
            const upcomingTimeStr = upcomingStartTime.toLocaleTimeString('en-US', { 
                hour: 'numeric', 
                minute: '2-digit',
                hour12: true 
            });
            
            // Format time until fast
            let timeUntilText = '';
            if (hoursUntil > 24) {
                const daysUntil = Math.round(hoursUntil / 24);
                timeUntilText = ` (in ${daysUntil} day${daysUntil === 1 ? '' : 's'})`;
            } else if (hoursUntil > 1) {
                timeUntilText = ` (in ${hoursUntil} hour${hoursUntil === 1 ? '' : 's'})`;
            } else if (hoursUntil === 1) {
                timeUntilText = ' (in 1 hour)';
            } else if (hoursUntil === 0) {
                timeUntilText = ' (starting now!)';
            }
            
            // Different styling and content based on actionability
            const label = isActionable ? 'Upcoming:' : 'Next:';
            const startEarlyButton = isActionable ? 
                `<button class="btn btn-start-early" onclick="startEarly('${upcomingFast.id}')">
                    Start Early
                </button>` : '';
            
            upcomingDiv.innerHTML = `
                <div class="upcoming-fast-content">
                    <div class="upcoming-text">
                        <strong>${label}</strong> ${dayName} ${upcomingTimeStr}${timeUntilText}
                        <br><small>${upcomingFast.block_name || 'Scheduled Fast'} • ${upcomingFast.duration_hours}h</small>
                    </div>
                    ${startEarlyButton}
                </div>
            `;
            
            // Apply different CSS class based on actionability
            upcomingDiv.className = isActionable ? 'upcoming-fast-notice actionable' : 'upcoming-fast-notice informational';
            upcomingDiv.style.display = 'block';
        }
        
        // Create upcoming fast notice element (pre-timer page only)
        function createUpcomingNotice() {
            const newUpcomingDiv = document.createElement('div');
            newUpcomingDiv.id = 'upcoming-fast-notice';
            newUpcomingDiv.className = 'upcoming-fast-notice';
            newUpcomingDiv.style.display = 'none';
            
            // Insert before START FAST NOW button on pre-timer page
            const startButton = document.querySelector('.start-fast-btn') || 
                              document.querySelector('#startFastBtn') ||
                              document.querySelector('button[onclick="startFast()"]');
            if (startButton) {
                startButton.parentNode.insertBefore(newUpcomingDiv, startButton);
            } else {
                // Final fallback: add to body
                document.body.appendChild(newUpcomingDiv);
            }
            
            return newUpcomingDiv;
        }
        
        // Handle start early action
        async function startEarly(upcomingId) {
            try {
                console.log('Starting early for upcoming fast:', upcomingId);
                
                // Show a confirmation dialog first per spec
                const confirmEarly = confirm('Do you want to start your scheduled fast early? This will update today\'s plan.');
                if (!confirmEarly) {
                    return;
                }
                
                // Call the start early API
                const earlyResponse = await fetch('/api/schedule/start-early', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: globalSessionId,
                        upcomingId: upcomingId
                    })
                });
                
                if (earlyResponse.ok) {
                    const result = await earlyResponse.json();
                    
                    // Set the fast ID for tracking
                    currentFastId = result.fastId;
                    
                    // Start the timer UI by setting up the state similar to startFast()
                    isRunning = true;
                    fastStartTime = new Date(); // Starting now for early start
                    elapsedTime = 0;
                    
                    // For early start, we need to get the duration from the result
                    // Assuming the API returns the duration
                    if (result.duration) {
                        fastDuration = result.duration;
                    } else {
                        fastDuration = 16; // Default to 16 hours if not provided
                    }
                    
                    // Save timer state to localStorage for persistence
                    const earlyStartTimerState = {
                        isRunning: true,
                        fastStartTime: fastStartTime.toISOString(),
                        fastDuration: fastDuration,
                        currentFastId: currentFastId
                    };
                    localStorage.setItem('fastingForecast_timerState', JSON.stringify(earlyStartTimerState));
                    
                    // Show active fast UI
                    document.getElementById('preFastState').style.display = 'none';
                    document.getElementById('activeFastState').style.display = 'block';
                    document.querySelector('.welcome-message').style.display = 'none';
                    
                    // Create milestone markers and update display
                    createMilestoneMarkers();
                    updateTimeDisplay();
                    updateTimerDisplay();
                    
                    // Start the timer interval
                    timerInterval = setInterval(() => {
                        elapsedTime = Date.now() - fastStartTime.getTime();
                        updateTimerDisplay();
                    }, 1000);
                    
                    // Hide the upcoming notice
                    const hideUpcomingDiv = document.getElementById('upcoming-fast-notice');
                    if (hideUpcomingDiv) {
                        hideUpcomingDiv.style.display = 'none';
                    }
                    
                    console.log('Scheduled fast started early:', result);
                } else {
                    const error = await earlyResponse.json();
                    alert('Failed to start early: ' + (error.error || 'Unknown error'));
                }
                
            } catch (error) {
                console.error('Error starting early:', error);
                alert('Failed to start early. Please try again.');
            }
        }
        
        // Check for active fast and upcoming fast when page loads - moved to session ready callback
        // checkForActiveFast();
        // checkForUpcomingFast();
    </script>
    
    <!-- Bottom Navigation -->
    <nav class="bottom-nav">
        <a href="/schedule" class="nav-item" data-page="schedule">
            <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                <line x1="16" y1="2" x2="16" y2="6"/>
                <line x1="8" y1="2" x2="8" y2="6"/>
                <line x1="3" y1="10" x2="21" y2="10"/>
            </svg>
            <span class="nav-label">Schedule</span>
        </a>
        
        <a href="/dashboard" class="nav-item" data-page="dashboard">
            <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="20" x2="18" y2="10"/>
                <line x1="12" y1="20" x2="12" y2="4"/>
                <line x1="6" y1="20" x2="6" y2="14"/>
            </svg>
            <span class="nav-label">Dashboard</span>
        </a>
        
        <a href="/timer" class="nav-item nav-primary active" data-page="timer">
            <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="13" r="9"/>
                <polyline points="12,7 12,13 16,15"/>
                <path d="M9,2 L15,2"/>
                <path d="M12,2 L12,6"/>
            </svg>
            <span class="nav-label">Timer</span>
        </a>
        
        <a href="/learning" class="nav-item" data-page="learning">
            <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/>
                <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/>
            </svg>
            <span class="nav-label">Learning Hub</span>
        </a>
        
        <a href="/settings" class="nav-item" data-page="settings">
            <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"/>
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
            </svg>
            <span class="nav-label">Settings</span>
        </a>
    </nav>

    <!-- Session Management -->
    <script src="/js/modules/session-manager.js"></script>
    <script src="/js/modules/page-session-guard.js"></script>
    <script>
        // Initialize session management first
        const pageGuard = new window.FastingForecastPageSessionGuard();
        window.pageGuard = pageGuard; // Make it available globally for getSessionId()

        // Wait for session to be ready before continuing with page logic
        pageGuard.waitForReady().then(() => {
            console.log('✓ Session manager ready for timer.html');

            // Test session ID
            const sessionId = window.getSessionId();
            console.log('✓ Current session ID:', sessionId);

            // Now that session is ready, check for active fast and upcoming fast
            console.log('✓ Starting timer initialization with session ready');

            checkForActiveFast().then(() => {
                console.log('✓ checkForActiveFast completed');
            }).catch(error => {
                console.error('✗ checkForActiveFast failed:', error);
            });

            checkForUpcomingFast().then(() => {
                console.log('✓ checkForUpcomingFast completed');
            }).catch(error => {
                console.error('✗ checkForUpcomingFast failed:', error);
            });
        }).catch(error => {
            console.error('✗ Session manager failed to initialize:', error);
        });
    </script>
</body>
</html>