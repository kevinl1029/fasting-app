<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fasting Timer - Your Journey</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/navigation.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #fcd34d 0%, #fb923c 50%, #ec4899 100%);
            min-height: 100vh;
            padding-bottom: 85px;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 480px;
            margin: 0 auto;
            padding: 20px;
            width: 100%;
        }
        
        .timer-card {
            background: white;
            border-radius: 20px;
            padding: 25px 30px 30px 30px;
            margin: 20px 0;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            text-align: center;
            min-height: 600px;
            max-height: none;
            display: flex;
            flex-direction: column;
            overflow: visible;
            transition: min-height 0.3s ease;
            justify-content: flex-start;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #28a745;
            display: inline-block;
            margin-right: 8px;
        }
        
        .status-indicator.fasting {
            background: #fb923c;
        }
        
        .status-indicator.feeding {
            background: #28a745;
        }
        
        .status-text {
            font-size: 1.1rem;
            font-weight: 600;
            color: #666;
            margin: 30px 0 20px 0;
        }

        /* Phase Banner Styles */
        .phase-banner {
            margin: 30px 0 20px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .phase-banner:hover {
            opacity: 0.9;
        }

        .banner-content {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            font-size: 1.1rem;
            font-weight: 600;
            color: #fb923c;
            flex-wrap: wrap;
        }

        .phase-section {
            display: flex;
            align-items: center;
            gap: 6px;
            color: #fb923c;
        }

        .phase-icon {
            font-size: 1.1em;
        }

        .banner-description {
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.08), rgba(236, 72, 153, 0.08));
            border-radius: 12px;
            margin-top: 12px;
            border-left: 4px solid #fb923c;
            transition: all 0.3s ease;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            padding: 0 16px;
        }

        .banner-description.slide-down {
            opacity: 1;
            max-height: 200px;
            padding: 16px;
        }

        .banner-description.hidden {
            display: none;
        }

        .banner-description p {
            margin: 0;
            color: #555;
            font-size: 0.95rem;
            line-height: 1.4;
        }

        .phase-banner.expanded .banner-content {
            margin-bottom: 8px;
        }
        
        .circular-timer {
            width: min(280px, 70vw);
            height: min(280px, 70vw);
            margin: 30px auto 20px;
            position: relative;
            border-radius: 50%;
            background: #f0f0f0;
            box-shadow: 
                inset 8px 8px 16px rgba(163, 177, 198, 0.6),
                inset -8px -8px 16px rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: visible; /* Allow pulse to expand beyond container */
        }
        
        .timer-progress-outer {
            position: absolute;
            top: 50%;
            left: 50%;
            width: calc(min(280px, 70vw) - 20px);
            height: calc(min(280px, 70vw) - 20px);
            border-radius: 50%;
            background: conic-gradient(#ec4899 0deg, #f0f0f0 0deg);
            transition: all 0.3s ease;
            transform: translate(-50%, -50%);
        }
        
        .timer-progress-inner {
            position: absolute;
            top: 50%;
            left: 50%;
            width: calc(min(280px, 70vw) - 50px);
            height: calc(min(280px, 70vw) - 50px);
            border-radius: 50%;
            background: conic-gradient(#fb923c 0deg, #f8f9fa 0deg);
            transition: all 0.3s ease;
            transform: translate(-50%, -50%);
        }
        
        .timer-progress-minute {
            position: absolute;
            top: 50%;
            left: 50%;
            width: calc(min(280px, 70vw) - 80px);
            height: calc(min(280px, 70vw) - 80px);
            border-radius: 50%;
            background: conic-gradient(#fcd34d 0deg, #f8f9fa 0deg);
            transition: all 0.3s ease;
            opacity: 0;
            transform: translate(-50%, -50%);
        }
        
        .timer-progress-minute.visible {
            opacity: 1;
        }
        
        .radar-pulse {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border: 2px solid rgba(252, 211, 77, calc(var(--pulse-opacity, 0.8)));
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: radarPulse 1s ease-out infinite;
            z-index: 1;
            opacity: 0;
            pointer-events: none;
        }
        
        .radar-pulse.visible {
            opacity: 1;
        }
        
        /* Milestone Markers */
        .milestone-marker {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #fff;
            border: 3px solid #ddd;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 5;
            transform: translate(-50%, -50%);
        }
        
        .milestone-marker.reached {
            background: #28a745;
            border-color: #28a745;
            box-shadow: 0 0 8px rgba(40, 167, 69, 0.4);
        }
        
        .milestone-marker.current {
            background: #fb923c;
            border-color: #fb923c;
            box-shadow: 0 0 12px rgba(251, 146, 60, 0.6);
            animation: milestoneGlow 2s ease-in-out infinite;
        }
        
        .milestone-marker:hover {
            transform: translate(-50%, -50%) scale(1.3);
            box-shadow: 0 0 15px rgba(251, 146, 60, 0.8);
        }
        
        @keyframes milestoneGlow {
            0%, 100% { box-shadow: 0 0 12px rgba(251, 146, 60, 0.6); }
            50% { box-shadow: 0 0 20px rgba(251, 146, 60, 0.9); }
        }
        
        /* Milestone Tooltip */
        .milestone-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 16px 20px;
            border-radius: 12px;
            font-size: 0.9rem;
            white-space: normal;
            max-width: 350px;
            word-wrap: break-word;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transform: translate(-50%, -50%) scale(0.9);
            transition: all 0.3s ease;
            pointer-events: auto;
            left: 50%;
            top: 50%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .milestone-tooltip.show {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) scale(1);
        }
        
        @keyframes radarPulse {
            0% {
                width: 0;
                height: 0;
                opacity: calc(var(--pulse-opacity, 0.8));
                border-width: 3px;
            }
            50% {
                opacity: calc(var(--pulse-opacity, 0.8) * 0.6);
                border-width: 2px;
            }
            100% {
                width: min(280px, 70vw);  /* Responsive to match timer size */
                height: min(280px, 70vw);
                opacity: 0;
                border-width: 1px;
            }
        }
        
        .timer-inner {
            position: absolute;
            top: 50%;
            left: 50%;
            width: calc(min(280px, 70vw) - 120px);
            height: calc(min(280px, 70vw) - 120px);
            border-radius: 50%;
            background: #f0f0f0;
            box-shadow: 
                8px 8px 16px rgba(163, 177, 198, 0.6),
                -8px -8px 16px rgba(255, 255, 255, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 4;
            transform: translate(-50%, -50%);
        }
        
        .timer-display {
            font-size: 2.5rem;
            font-weight: 700;
            color: #333;
            font-family: 'Courier New', monospace;
            margin: 5px 0;
        }
        
        .timer-label {
            font-size: 0.9rem;
            color: #666;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .upcoming-fast-notice {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(147, 51, 234, 0.1));
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 15px;
            padding: 15px 20px;
            margin: 20px 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }
        
        .upcoming-fast-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .upcoming-text {
            flex: 1;
            color: #1e40af;
            font-size: 0.95rem;
            line-height: 1.4;
        }
        
        .upcoming-text strong {
            color: #1e3a8a;
            font-weight: 600;
        }
        
        .upcoming-text small {
            color: #64748b;
            font-size: 0.85rem;
        }
        
        .btn-start-early {
            background: linear-gradient(135deg, #3b82f6, #6366f1);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        
        .btn-start-early:hover {
            background: linear-gradient(135deg, #2563eb, #4f46e5);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        /* Actionable upcoming fast - within 6 hours, Start Early available */
        .upcoming-fast-notice.actionable {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.12), rgba(147, 51, 234, 0.12));
            border: 1px solid rgba(59, 130, 246, 0.25);
            animation: subtle-glow 3s ease-in-out infinite alternate;
        }
        
        @keyframes subtle-glow {
            from { box-shadow: 0 4px 12px rgba(59, 130, 246, 0.1); }
            to { box-shadow: 0 6px 20px rgba(59, 130, 246, 0.15); }
        }
        
        /* Informational upcoming fast - distant future, just awareness */
        .upcoming-fast-notice.informational {
            background: linear-gradient(135deg, rgba(107, 114, 128, 0.08), rgba(156, 163, 175, 0.08));
            border: 1px solid rgba(107, 114, 128, 0.15);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.03);
        }
        
        .upcoming-fast-notice.informational .upcoming-text {
            color: #6b7280;
        }
        
        .upcoming-fast-notice.informational .upcoming-text strong {
            color: #4b5563;
        }
        
        .upcoming-fast-notice.informational .upcoming-text small {
            color: #9ca3af;
        }
        
        .phase-info {
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.08), rgba(236, 72, 153, 0.08));
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 4px solid #fb923c;
        }
        
        .phase-title {
            color: #fb923c;
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 10px;
        }
        
        .phase-description {
            color: #666;
            font-size: 0.95rem;
            line-height: 1.5;
        }
        
        .start-fast-btn {
            width: 100%;
            max-width: 300px;
            margin: 0 auto 30px;
            padding: 20px 40px;
            border: none;
            border-radius: 15px;
            font-size: 1.3rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #fcd34d 0%, #fb923c 50%, #ec4899 100%);
            color: white;
            box-shadow: 0 8px 25px rgba(251, 146, 60, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .start-fast-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(251, 146, 60, 0.5);
        }
        
        .draft-ready {
            border: 2px dashed rgba(236, 72, 153, 0.25);
            border-radius: 18px;
            padding: 16px;
            margin-top: 10px;
        }

        .draft-ready .start-fast-btn {
            margin-bottom: 12px;
        }

        .sticky-start-btn {
            position: fixed;
            bottom: 90px; /* Space above bottom nav (75px) + extra margin */
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            width: calc(100% - 40px);
            max-width: 350px;
            padding: 16px 32px;
            border: none;
            border-radius: 15px;
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #fcd34d 0%, #fb923c 50%, #ec4899 100%);
            color: white;
            box-shadow: 0 8px 25px rgba(251, 146, 60, 0.6), 0 0 0 1px rgba(255,255,255,0.1);
            text-transform: uppercase;
            letter-spacing: 1px;
            display: none;
        }
        
        /* Adjust for mobile safe area */
        @media (max-width: 768px) {
            .sticky-start-btn {
                bottom: max(90px, calc(75px + env(safe-area-inset-bottom) + 15px));
            }
        }
        
        .sticky-start-btn:hover {
            transform: translateX(-50%) translateY(-3px);
            box-shadow: 0 12px 35px rgba(251, 146, 60, 0.7), 0 0 0 1px rgba(255,255,255,0.2);
        }
        
        .sticky-start-btn .duration-badge {
            display: block;
            font-size: 0.9rem;
            opacity: 0.9;
            font-weight: 500;
            margin-top: 2px;
            text-transform: none;
            letter-spacing: normal;
        }
        
        .control-buttons {
            display: flex;
            gap: 15px;
            margin-top: auto;
            margin-bottom: 15px;
            padding-top: 20px;
            justify-content: center;
        }
        
        .btn {
            flex: 1;
            padding: 15px 20px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #fcd34d 0%, #fb923c 50%, #ec4899 100%);
            color: white;
        }
        
        .btn-secondary {
            background: transparent;
            border: 2px solid #fb923c;
            color: #fb923c;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(251, 146, 60, 0.4);
        }
        
        .scheduled-fast {
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.08), rgba(236, 72, 153, 0.08));
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 4px solid #fb923c;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .scheduled-fast:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(251, 146, 60, 0.15);
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.12), rgba(236, 72, 153, 0.12));
        }

        .scheduled-fast.scheduled-actionable {
            border-left-color: #22c55e;
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.12), rgba(59, 130, 246, 0.12));
        }

        .scheduled-fast.scheduled-recent {
            border-left-color: #f97316;
            background: linear-gradient(135deg, rgba(249, 115, 22, 0.12), rgba(236, 72, 153, 0.12));
        }
        
        .scheduled-title {
            color: #fb923c;
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 10px;
        }
        
        .scheduled-info {
            color: #666;
            font-size: 0.95rem;
            line-height: 1.4;
        }
        
        .new-user-welcome {
            background: linear-gradient(135deg, rgba(40, 167, 69, 0.08), rgba(251, 146, 60, 0.08));
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 4px solid #28a745;
            text-align: center;
        }
        
        .welcome-title {
            color: #28a745;
            font-weight: 700;
            font-size: 1.3rem;
            margin-bottom: 12px;
        }
        
        .welcome-subtitle {
            color: #666;
            font-size: 1rem;
            line-height: 1.4;
            margin-bottom: 15px;
        }
        
        .welcome-hint {
            color: #999;
            font-size: 0.85rem;
            margin-top: 15px;
            font-style: italic;
        }
        
        .schedule-setup-state {
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.08), rgba(236, 72, 153, 0.08));
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 4px solid #fb923c;
            text-align: center;
        }
        
        .schedule-title {
            color: #fb923c;
            font-weight: 700;
            font-size: 1.3rem;
            margin-bottom: 12px;
        }
        
        .schedule-subtitle {
            color: #666;
            font-size: 1rem;
            line-height: 1.4;
            margin-bottom: 15px;
        }
        
        .dual-button-group {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }
        
        .schedule-btn-primary {
            flex: 1;
            padding: 15px 20px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #fb923c 0%, #ec4899 100%);
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .schedule-btn-secondary {
            flex: 1;
            padding: 15px 20px;
            border: 2px solid #fb923c;
            border-radius: 10px;
            background: transparent;
            color: #fb923c;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .schedule-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(251, 146, 60, 0.3);
        }
        
        .schedule-btn-secondary:hover {
            transform: translateY(-2px);
            background: rgba(251, 146, 60, 0.05);
        }

        /* Hunger Coach Card - Updated Design System */
        .hunger-coach-card {
            margin: 25px 0;
            padding: 24px;
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.08), rgba(14, 165, 233, 0.06));
            border-radius: 16px;
            border: 1px solid rgba(6, 182, 212, 0.15);
            box-shadow: 0 4px 16px rgba(6, 182, 212, 0.08);
            min-height: 140px;
            transition: all 0.4s ease;
            opacity: 1;
            transform: translateY(0);
            cursor: pointer;
        }

        .hunger-coach-card.hidden {
            display: none;
        }

        .hunger-coach-card.slide-in {
            animation: slideInUp 0.5s ease-out;
        }

        .hunger-coach-card.fading {
            opacity: 0.6;
        }

        /* Card Content Container */
        .card-content {
            display: flex;
            flex-direction: column;
            height: 100%;
            justify-content: space-between;
        }

        /* Inline Icon + Message */
        .card-message {
            font-size: 17px;
            font-weight: 500;
            line-height: 1.5;
            color: #1f2937;
            margin: 0 0 16px 0;
            opacity: 1;
            transition: opacity 0.4s ease;
        }

        .card-message.fading {
            opacity: 0;
        }

        .inline-icon {
            font-size: 1.3rem;
            margin-right: 8px;
            vertical-align: baseline;
        }

        /* Extended Content */
        .card-extended {
            margin: 16px 0;
            padding-top: 16px;
            border-top: 1px solid rgba(6, 182, 212, 0.15);
            transition: all 0.3s ease;
        }

        .extended-text {
            font-size: 15px;
            font-weight: 400;
            line-height: 1.4;
            color: #6b7280;
            margin: 0;
        }

        /* Expanded state */
        .hunger-coach-card.expanded {
            min-height: 200px;
        }

        /* See More Link */
        .see-more-link {
            color: #0891b2;
            font-size: 14px;
            font-weight: 600;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            margin-top: auto;
            transition: all 0.2s ease;
        }

        .see-more-link:hover {
            color: #0e7490;
            text-decoration: underline;
        }

        .see-more-link:after {
            content: "‚Üí";
            margin-left: 4px;
            transition: transform 0.2s ease;
        }

        .see-more-link:hover:after {
            transform: translateX(2px);
        }

        /* Slide-in Animation */
        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Hover Effect */
        .hunger-coach-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(6, 182, 212, 0.12);
        }

        /* Benefits Card - Matching Design System */
        .benefits-card {
            margin: 25px 0;
            padding: 24px;
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.08), rgba(5, 150, 105, 0.06));
            border-radius: 16px;
            border: 1px solid rgba(16, 185, 129, 0.15);
            box-shadow: 0 4px 16px rgba(16, 185, 129, 0.08);
            min-height: 140px;
            transition: all 0.4s ease;
            opacity: 1;
            transform: translateY(0);
            cursor: pointer;
        }

        .benefits-card.hidden {
            display: none;
        }

        .benefits-card.slide-in {
            animation: slideInUp 0.5s ease-out;
        }

        .benefits-card.fading {
            opacity: 0.6;
        }

        .benefits-card.expanded {
            min-height: 200px;
            box-shadow: 0 8px 32px rgba(16, 185, 129, 0.15);
        }

        .benefits-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(16, 185, 129, 0.12);
        }

        .time-display {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .time-item {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin: 12px 0;
            min-height: 24px;
        }
        
        .time-label {
            color: #666;
            font-weight: 500;
            font-size: 0.95rem;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .time-value {
            color: #333;
            font-weight: 600;
            font-size: 0.95rem;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            text-align: right;
            line-height: 1.2;
        }
        
        .time-value-container {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 8px;
        }
        
        .adjust-time-btn {
            background: transparent;
            border: 1px solid #ddd;
            color: #666;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.7;
        }
        
        .adjust-time-btn:hover {
            border-color: #fb923c;
            color: #fb923c;
            opacity: 1;
        }
        
        .time-adjustment-controls {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 6px;
            flex-wrap: wrap;
        }
        
        .time-adjustment-controls input[type="time"],
        .time-adjustment-controls select {
            padding: 4px 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.8rem;
            font-family: inherit;
        }
        
        .time-adjustment-controls input[type="time"]:focus,
        .time-adjustment-controls select:focus {
            border-color: #fb923c;
            outline: none;
            box-shadow: 0 0 0 2px rgba(251, 146, 60, 0.1);
        }
        
        .apply-adjustment-btn,
        .cancel-adjustment-btn {
            padding: 4px 8px;
            border: none;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .apply-adjustment-btn {
            background: #28a745;
            color: white;
        }
        
        .apply-adjustment-btn:hover {
            background: #218838;
        }
        
        .cancel-adjustment-btn {
            background: #6c757d;
            color: white;
        }
        
        .cancel-adjustment-btn:hover {
            background: #5a6268;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 25px 0;
        }
        
        .stat-item {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #333;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #666;
            margin-top: 5px;
        }
        
        .welcome-message {
            text-align: center;
            color: white;
            padding: 20px 0;
            margin-bottom: 20px;
        }
        
        .welcome-message h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
            font-weight: 700;
        }
        
        .welcome-message p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .customize-duration {
            text-align: center;
            margin: 15px 0;
        }
        
        .customize-btn {
            background: transparent;
            border: 1px solid #fb923c;
            color: #fb923c;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .customize-btn:hover {
            background: rgba(251, 146, 60, 0.1);
            transform: translateY(-1px);
        }
        
        .duration-selector {
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.05), rgba(236, 72, 153, 0.05));
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            border: 1px solid rgba(251, 146, 60, 0.2);
            transition: all 0.3s ease;
        }
        
        .duration-presets h4 {
            color: #fb923c;
            font-size: 1.1rem;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .preset-btn {
            position: relative;
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }
        
        .preset-btn:hover {
            border-color: #fb923c;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(251, 146, 60, 0.2);
        }
        
        .preset-btn.active {
            border-color: #fb923c;
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.1), rgba(236, 72, 153, 0.1));
            box-shadow: 0 4px 12px rgba(251, 146, 60, 0.3);
        }
        
        .preset-btn.selected-confirmation {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(251, 146, 60, 0.1));
            border-color: #22c55e;
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
            transform: scale(1.02);
        }
        
        .preset-btn .checkmark {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 20px;
            height: 20px;
            background: #22c55e;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            font-weight: bold;
        }
        
        .preset-btn.selected-confirmation .checkmark {
            display: flex;
        }
        
        .preset-btn .duration {
            display: block;
            font-weight: 700;
            font-size: 1.1rem;
            color: #333;
            margin-bottom: 4px;
        }
        
        .preset-btn .description {
            display: block;
            font-size: 0.8rem;
            color: #666;
            line-height: 1.2;
        }
        
        .custom-duration {
            border-top: 1px solid rgba(251, 146, 60, 0.2);
            padding-top: 15px;
        }
        
        .custom-duration label {
            display: block;
            color: #fb923c;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .custom-input {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .custom-input input {
            width: 80px;
            padding: 8px 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 1rem;
            text-align: center;
        }
        
        .custom-input input:focus {
            border-color: #fb923c;
            outline: none;
            box-shadow: 0 0 0 3px rgba(251, 146, 60, 0.1);
        }
        
        .custom-input span {
            color: #666;
            font-weight: 500;
        }
        
        .apply-custom-btn {
            background: linear-gradient(135deg, #fcd34d 0%, #fb923c 50%, #ec4899 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .apply-custom-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(251, 146, 60, 0.4);
        }
        
        .start-time-section {
            border-top: 1px solid rgba(251, 146, 60, 0.2);
            padding-top: 15px;
            margin-top: 15px;
        }
        
        .start-time-section > label {
            display: block;
            color: #fb923c;
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        .start-time-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .radio-option {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            color: #333;
            font-weight: 500;
        }
        
        .radio-option input[type="radio"] {
            margin: 0;
        }
        
        .time-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
            padding: 8px;
            background: rgba(251, 146, 60, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(251, 146, 60, 0.1);
        }
        
        .time-input-group input[type="time"] {
            padding: 6px 10px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 0.95rem;
            font-family: inherit;
        }
        
        .time-input-group input[type="time"]:focus {
            border-color: #fb923c;
            outline: none;
            box-shadow: 0 0 0 2px rgba(251, 146, 60, 0.1);
        }
        
        .time-input-group select {
            padding: 6px 10px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 0.95rem;
            background: white;
            cursor: pointer;
        }
        
        .time-input-group select:focus {
            border-color: #fb923c;
            outline: none;
            box-shadow: 0 0 0 2px rgba(251, 146, 60, 0.1);
        }

        /* Fast Completion State */
        .completion-state {
            text-align: center;
            animation: fadeInUp 0.6s ease;
        }
        
        .completion-header {
            margin-bottom: 30px;
        }
        
        .completion-header h2 {
            color: #28a745;
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 10px;
        }
        
        .completion-header .celebration {
            font-size: 3rem;
            margin-bottom: 15px;
        }
        
        .completion-summary {
            background: linear-gradient(135deg, rgba(40, 167, 69, 0.08), rgba(251, 146, 60, 0.08));
            border-radius: 20px;
            padding: 25px;
            margin: 25px 0;
            border: 2px solid #28a745;
            box-shadow: 0 8px 25px rgba(40, 167, 69, 0.15);
        }
        
        .summary-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 25px;
        }
        
        .summary-stat {
            text-align: center;
        }
        
        .summary-stat .value {
            font-size: 2.2rem;
            font-weight: 700;
            color: #28a745;
            display: block;
            margin-bottom: 5px;
        }
        
        .summary-stat .label {
            font-size: 0.9rem;
            color: #666;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .milestones-achieved {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .milestones-achieved h4 {
            color: #28a745;
            font-size: 1.1rem;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .milestone-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .milestone-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #28a745;
        }
        
        .milestone-item .icon {
            font-size: 1.3rem;
            width: 30px;
            text-align: center;
        }
        
        .milestone-item .info {
            flex: 1;
        }
        
        .milestone-item .title {
            font-weight: 600;
            color: #333;
            font-size: 0.95rem;
            margin-bottom: 2px;
        }
        
        .milestone-item .time {
            font-size: 0.8rem;
            color: #666;
        }
        
        .completion-actions {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 25px;
        }

        .schedule-draft-btn {
            background: linear-gradient(135deg, #10b981 0%, #22d3ee 100%);
            color: white;
            border: none;
            padding: 16px 30px;
            border-radius: 12px;
            font-size: 1.05rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .schedule-draft-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(34, 211, 238, 0.3);
        }

        .refeed-notes-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 18px 30px;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 6px 20px rgba(40, 167, 69, 0.3);
        }
        
        .refeed-notes-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(40, 167, 69, 0.4);
        }
        
        .new-fast-btn {
            background: transparent;
            border: 2px solid #fb923c;
            color: #fb923c;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .new-fast-btn:hover {
            background: rgba(251, 146, 60, 0.1);
            transform: translateY(-1px);
        }
        
        /* Confetti Canvas */
        #confettiCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .timer-card {
                min-height: 500px;
                max-height: none;
                padding: 18px 20px 25px 20px;
                justify-content: flex-start;
            }
            
            .control-buttons {
                margin-top: auto;
                margin-bottom: 12px;
                padding-top: 15px;
            }
            
            .circular-timer {
                width: min(280px, 70vw);
                height: min(280px, 70vw);
                margin: 20px auto 15px;
            }
            
            .status-text {
                margin: 25px 0 15px 0;
                font-size: 1rem;
            }

            /* Phase Banner Mobile Styles */
            .phase-banner {
                margin: 25px 0 15px 0;
            }

            .banner-content {
                font-size: 1rem;
                gap: 6px;
                text-align: center;
            }

            .phase-section {
                justify-content: center;
            }

            .banner-description {
                padding: 12px;
                border-radius: 10px;
            }

            .banner-description p {
                font-size: 0.9rem;
            }
            
            .control-buttons {
                margin: 15px 0 25px 0;
            }
            
            .timer-display {
                font-size: 2.5rem;
            }
            
            .control-buttons {
                flex-direction: column;
            }
            
            .preset-buttons {
                grid-template-columns: 1fr;
            }
            
            .summary-stats {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .completion-header h2 {
                font-size: 1.6rem;
            }
            
            .completion-header .celebration {
                font-size: 2.5rem;
            }
        }
        
    </style>

    <!-- Session Management Scripts - Load Early -->
    <script src="/js/modules/session-manager.js"></script>
    <script src="/js/modules/page-session-guard.js"></script>
</head>
<body>
    <div class="container">
        <div class="welcome-message">
            <h1>Welcome back!</h1>
            <p>Ready for your next fasting session?</p>
        </div>
        
        <div class="timer-card">
            <!-- Pre-Fast State -->
            <div id="preFastState">
                <!-- New User Welcome State -->
                <div id="newUserWelcome" class="new-user-welcome" style="display: none;">
                    <div class="welcome-title">üéâ Welcome to Your Fasting Journey!</div>
                    <div class="welcome-subtitle">Ready to start your first fast?</div>
                </div>
                
                <!-- Schedule Setup State (for returning users) -->
                <div id="scheduleSetupState" class="schedule-setup-state" style="display: none;">
                    <div class="schedule-title">üìÖ Want to make fasting easier?</div>
                    <div class="schedule-subtitle">Set up a regular schedule to stay on track</div>
                    <button class="schedule-btn-secondary" onclick="showScheduleSetup()" style="margin-top: 15px;">Set My Schedule</button>
                </div>
                
                <!-- Scheduled Fast State -->
                <div id="scheduledFastInfo" class="scheduled-fast" style="display: none;" onclick="showScheduleSetup()">
                    <div class="scheduled-title">üóìÔ∏è Next Scheduled Fast</div>
                    <div class="scheduled-info">
                        <span id="scheduledFastDetails">Tomorrow at 8:00 PM ‚Ä¢ 24-hour fast</span><br>
                        <small style="opacity: 0.7;">Tap to modify schedule</small>
                    </div>
                </div>
                
                <button class="start-fast-btn" id="startFastBtn" onclick="startFast()">
                    Start Your First Fast
                </button>
                
                <button class="sticky-start-btn" id="stickyStartBtn" onclick="startFast()" style="display: none;">
                    <span id="stickyBtnText">Start 24h Fast</span>
                    <span class="duration-badge" id="stickyBtnBadge">Selected: 24 hours</span>
                </button>
                
                <div id="newUserHint" class="welcome-hint" style="display: none;">
                    Choose your duration below or start with 24 hours
                </div>
                
                
                <div class="customize-duration">
                    <button class="customize-btn" onclick="toggleDurationSelector()">
                        Customize Duration ‚öôÔ∏è
                    </button>
                </div>
                
                <div class="duration-selector" id="durationSelector" style="display: none;">
                    <div class="duration-presets">
                        <h4>Choose Duration</h4>
                        <div class="preset-buttons">
                            <button class="preset-btn active" data-hours="24" onclick="selectDuration(24, { userInitiated: true })">
                                <span class="duration">24h</span>
                                <span class="description">Metabolic reset & fat burning</span>
                                <span class="checkmark">‚úì</span>
                            </button>
                            <button class="preset-btn" data-hours="36" onclick="selectDuration(36, { userInitiated: true })">
                                <span class="duration">36h</span>
                                <span class="description">Deep ketosis & mental clarity</span>
                                <span class="checkmark">‚úì</span>
                            </button>
                            <button class="preset-btn" data-hours="48" onclick="selectDuration(48, { userInitiated: true })">
                                <span class="duration">48h</span>
                                <span class="description">Peak autophagy & cellular renewal</span>
                                <span class="checkmark">‚úì</span>
                            </button>
                            <button class="preset-btn" data-hours="72" onclick="selectDuration(72, { userInitiated: true })">
                                <span class="duration">72h</span>
                                <span class="description">Extended therapeutic benefits</span>
                                <span class="checkmark">‚úì</span>
                            </button>
                        </div>
                        
                        <div class="custom-duration">
                            <label for="customHours">Custom Duration:</label>
                            <div class="custom-input">
                                <input type="number" id="customHours" min="1" max="168" placeholder="24">
                                <span>hours</span>
                                <button class="apply-custom-btn" onclick="applyCustomDuration()">Apply Custom Duration</button>
                            </div>
                        </div>
                        
                        <div class="start-time-section">
                            <label>Start Time:</label>
                            <div class="start-time-options">
                                <label class="radio-option">
                                    <input type="radio" name="startTime" value="now" checked onchange="toggleStartTimeInputs()">
                                    <span>Start now</span>
                                </label>
                                <label class="radio-option">
                                    <input type="radio" name="startTime" value="custom" onchange="toggleStartTimeInputs()">
                                    <span>Started at:</span>
                                </label>
                            </div>
                            <div class="time-input-group" id="timeInputGroup" style="display: none;">
                                <input type="time" id="startTimeInput" onchange="updateSelectedStartTime(); updateStartButtonText();">
                                <select id="startDateOffset" onchange="updateSelectedStartTime(); updateStartButtonText();">
                                    <option value="0">Today</option>
                                    <option value="1">Yesterday</option>
                                    <option value="2">2 days ago</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="totalFasts">0</div>
                        <div class="stat-label">Completed Fasts</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="longestFast">0h</div>
                        <div class="stat-label">Longest Fast</div>
                    </div>
                </div>
            </div>
            
            <!-- Active Fast State -->
            <div id="activeFastState" style="display: none;">
                <div id="phaseBanner" class="phase-banner">
                    <div class="banner-content" id="bannerContent">
                        <span class="phase-section" id="phaseSection">
                            <span class="phase-icon">üåü</span>
                            <span id="phaseText">Getting Started</span>
                        </span>
                    </div>
                    <div class="banner-description hidden" id="bannerDescription">
                        <p id="phaseDescription">Your body is beginning to use stored glucose and transitioning away from constant feeding.</p>
                    </div>
                </div>
                
                <div class="circular-timer">
                    <div class="timer-progress-outer" id="timerProgressOuter"></div>
                    <div class="timer-progress-inner" id="timerProgressInner"></div>
                    <div class="timer-progress-minute" id="timerProgressMinute"></div>
                    <div class="radar-pulse" id="radarPulse"></div>
                    
                    <!-- Milestone Markers -->
                    <div id="milestoneMarkers"></div>
                    
                    <div class="timer-inner">
                        <div class="timer-display" id="timerDisplay">12:30</div>
                        <div class="timer-label" id="timerLabel">ELAPSED</div>
                    </div>
                </div>

                <!-- Contextual Cards (Hunger Coach + Benefits) -->
                <!-- Hunger Coach Card -->
                <div class="hunger-coach-card hidden" id="hungerCoachCard" onclick="handleCardTap(event)">
                    <!-- Inline Icon + Message Content -->
                    <div class="card-content">
                        <p class="card-message" id="hungerCardMessage">
                            <span class="inline-icon" id="hungerCardIcon">üçµ</span>
                            <span id="hungerCardText">Loading helpful tips...</span>
                        </p>

                        <!-- Extended content shown on tap -->
                        <div class="card-extended" id="hungerCardExtended" style="display: none;">
                            <p class="extended-text" id="hungerExtendedText">Additional context and tips will appear here when you tap the card.</p>
                        </div>

                        <!-- See More Link -->
                        <a href="#" class="see-more-link" id="hungerSeeMoreLink" onclick="handleSeeMoreClick(event)">See More</a>
                    </div>
                </div>

                <!-- Benefits Card -->
                <div class="benefits-card hidden" id="benefitsCard" onclick="handleBenefitsCardTap(event)">
                    <!-- Inline Icon + Message Content -->
                    <div class="card-content">
                        <p class="card-message" id="benefitsCardMessage">
                            <span class="inline-icon" id="benefitsCardIcon">üí∞</span>
                            <span id="benefitsCardText">Loading benefits...</span>
                        </p>

                        <!-- Extended content shown on tap -->
                        <div class="card-extended" id="benefitsCardExtended" style="display: none;">
                            <p class="extended-text" id="benefitsExtendedText">Detailed benefits information will appear here when you tap the card.</p>
                        </div>

                        <!-- See More Link -->
                        <a href="#" class="see-more-link" id="benefitsSeeMoreLink" onclick="handleBenefitsSeeMoreClick(event)">View Dashboard</a>
                    </div>
                </div>

                <div class="time-display">
                    <div class="time-item">
                        <span class="time-label">Started</span>
                        <div class="time-value-container">
                            <span class="time-value" id="startTime">8:00 PM</span>
                            <button class="adjust-time-btn" id="adjustStartBtn" onclick="toggleStartTimeAdjustment()">
                                <small>adjust</small>
                            </button>
                        </div>
                    </div>
                    <div class="time-item" id="startTimeAdjustment" style="display: none;">
                        <div class="time-adjustment-controls">
                            <input type="time" id="adjustTimeInput">
                            <select id="adjustDateOffset">
                                <option value="0">Today</option>
                                <option value="1">Yesterday</option>
                                <option value="2">2 days ago</option>
                            </select>
                            <button class="apply-adjustment-btn" onclick="applyStartTimeAdjustment()">Apply</button>
                            <button class="cancel-adjustment-btn" onclick="cancelStartTimeAdjustment()">Cancel</button>
                        </div>
                    </div>
                    <div class="time-item">
                        <span class="time-label">Target End</span>
                        <span class="time-value" id="endTime">8:00 PM</span>
                    </div>
                </div>
                
                <!-- Phase info moved to banner above the fold -->
                <div class="phase-info" id="phaseInfo" style="display: none;">
                    <div class="phase-title" id="phaseTitle">Metabolic Shift</div>
                    <div class="phase-description" id="phaseDescription">
                        Your body is starting to switch from glucose to fat burning. Energy may fluctuate.
                    </div>
                </div>
                
                <div class="control-buttons">
                    <button class="btn btn-secondary" onclick="endFast()">
                        End Fast
                    </button>
                    <button class="btn btn-secondary" onclick="resetTimer()">
                        Reset
                    </button>
                </div>
            </div>
            
            <!-- Fast Completion State -->
            <div id="completionState" style="display: none;">
                <div class="completion-state">
                    <div class="completion-header">
                        <div class="celebration">üéâ</div>
                        <h2>Fast Complete!</h2>
                        <p style="color: #666; font-size: 1.1rem;">Congratulations on completing your fast!</p>
                    </div>
                    
                    <div class="completion-summary">
                        <div class="summary-stats">
                            <div class="summary-stat">
                                <span class="value" id="completionDuration">24:00</span>
                                <span class="label">Total Time</span>
                            </div>
                            <div class="summary-stat">
                                <span class="value" id="completionCalories">~1,800</span>
                                <span class="label">Est. Calories Burned</span>
                            </div>
                        </div>
                        
                        <div class="milestones-achieved">
                            <h4>üèÜ Milestones Achieved</h4>
                            <div class="milestone-list" id="completionMilestones">
                                <!-- Milestones will be populated here -->
                            </div>
                        </div>
                    </div>
                    
                    <div class="completion-actions">
                        <button class="refeed-notes-btn" onclick="openRefeedNotes()">
                            üìù Log Refeed Notes
                        </button>
                        <button class="schedule-draft-btn" id="addToScheduleBtn">
                            Add this to My Schedule
                        </button>
                        <button class="new-fast-btn" onclick="startNewFast()">
                            Start New Fast
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Confetti Canvas -->
    <canvas id="confettiCanvas"></canvas>

    <!-- Hunger Coach Module -->
    <script src="/js/modules/hunger-coach.js"></script>
    <script src="/js/modules/notification-service.js"></script>
    <script src="/js/modules/global-notification-manager.js"></script>

    <!-- Contextual Cards System -->
    <script src="/js/components/ContextualCard.js"></script>
    <script src="/js/components/HungerCoachCard.js"></script>
    <script src="/js/components/BenefitsCard.js"></script>
    <script src="/js/services/MealTimeDetector.js"></script>
    <script src="/js/services/BenefitsCalculator.js"></script>
    <script src="/js/services/BenefitsDataService.js"></script>
    <script src="/js/managers/CardRotationManager.js"></script>
    <script src="/js/components/PhaseBanner.js"></script>
    <script src="/js/modules/draft-schedule-api.js"></script>
    <script src="/js/modules/timer-onboarding-controller.js"></script>
    <script src="/js/modules/fast-duration-resolver.js"></script>

    <script>
        // Timer state
        let isRunning = false;
        let fastStartTime = null;
        let elapsedTime = 0;
        let timerInterval = null;
        let fastDuration = 24; // Default 24-hour fast
        let selectedDuration = 24; // Selected duration for next fast
        let selectedStartTime = null; // Selected start time (null = start now)
        let durationResolver = null;
        let latestScheduleWindow = null;
        let scheduledFastContext = null;
        let isScheduledFastActionable = false;
        let canStartScheduledFast = false;
        let hasUserAdjustedDuration = false;
        let autoSelectedDuration = 24;
        
        // Session management - use global function from PageGuard
        const globalSessionId = window.getSessionId();
        const clientTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';

        // Contextual Cards System
        let notificationService = null;
        const CARD_ROTATION_INTERVAL = 12000; // 12 seconds

        // Legacy hunger coach for backwards compatibility

        // Milestone definitions
        const milestones = [
            {
                hours: 12,
                title: "Glycogen Depletion Begins",
                message: "Your body is running low on stored glycogen and beginning to shift toward fat burning.",
                icon: "‚ö°"
            },
            {
                hours: 18,
                title: "Ketosis Transition",
                message: "Ketones are rising - you're switching to fat for fuel. Mental clarity often improves.",
                icon: "üî•"
            },
            {
                hours: 30,
                title: "Sustained Fat-Burning",
                message: "Fat is now your body's main energy source. You're in a deep metabolic state.",
                icon: "üí™"
            },
            {
                hours: 48,
                title: "Cellular Renewal (Autophagy)",
                message: "Your cells are recycling and repairing. Maximum therapeutic benefits activated.",
                icon: "‚ú®"
            }
        ];

        // Phase Banner Functions
        function initializePhaseBanner() {
            try {
                if (window.PhaseBanner) {
                    phaseBanner = new PhaseBanner({
                        expandOnClick: true,
                        animationDuration: 300
                    });
                    const success = phaseBanner.init();
                    if (success) {
                        return true;
                    } else {
                        console.warn('Phase Banner initialization failed');
                        return false;
                    }
                } else {
                    console.warn('PhaseBanner class not available');
                    return false;
                }
            } catch (error) {
                console.error('Failed to initialize Phase Banner:', error);
                return false;
            }
        }

        // Card Rotation Manager Functions
        async function initializeCardRotationManager() {
            try {
                if (window.CardRotationManager) {
                    cardRotationManager = new CardRotationManager({
                        rotationInterval: CARD_ROTATION_INTERVAL,
                        mealTimeToleranceMinutes: 30,
                        enableRotation: true
                    });

                    await cardRotationManager.init();
                    console.log('Card Rotation Manager initialized successfully');
                    return true;
                } else {
                    console.warn('CardRotationManager not available, falling back to legacy hunger coach');
                    return await initializeLegacyHungerCoach();
                }
            } catch (error) {
                console.error('Failed to initialize Card Rotation Manager:', error);
                console.log('Falling back to legacy hunger coach');
                return await initializeLegacyHungerCoach();
            }
        }

        // Legacy Hunger Coach Functions (fallback)
        async function initializeLegacyHungerCoach() {
            try {
                hungerCoach = new HungerCoach();
                await hungerCoach.init();
                console.log('Legacy Hunger Coach initialized');
                return true;
            } catch (error) {
                console.error('Failed to initialize Legacy Hunger Coach:', error);
                hungerCoach = null;
                return false;
            }
        }

        // Notification Service Functions
        async function initializeNotificationService() {
            try {
                notificationService = new NotificationService();
                console.log('Notification Service initialized');

                // Request permission on first initialization
                if (notificationService.permission === 'default') {
                    await notificationService.requestPermission();
                }
            } catch (error) {
                console.error('Failed to initialize Notification Service:', error);
                notificationService = null;
            }
        }

        async function showContextualCards() {
            if (cardRotationManager && isRunning) {
                try {
                    // Get user meal times for context
                    const mealtimes1 = await getUserMealtimes();

                    // Update fast state in card rotation manager
                    cardRotationManager.updateFastState(isRunning, fastStartTime, mealtimes1);

                    console.log('Contextual cards updated for active fast');
                } catch (error) {
                    console.error('Error showing contextual cards:', error);

                    // Fallback to legacy hunger coach
                    await showLegacyHungerCoachCard();
                }
            } else if (hungerCoach && isRunning) {
                // Fallback to legacy implementation
                await showLegacyHungerCoachCard();
            }
        }

        function hideContextualCards() {
            if (cardRotationManager) {
                try {
                    // Hide cards by updating fast state
                    cardRotationManager.updateFastState(false, null, null);
                    console.log('Contextual cards hidden');
                } catch (error) {
                    console.error('Error hiding contextual cards:', error);
                    hideLegacyHungerCoachCard();
                }
            } else {
                // Fallback to legacy implementation
                hideLegacyHungerCoachCard();
            }
        }

        // Legacy implementations for fallback
        async function showLegacyHungerCoachCard() {
            const hungerCard = document.getElementById('hungerCoachCard');
            if (hungerCard && hungerCoach && isRunning) {
                hungerCard.classList.remove('hidden');
                hungerCard.classList.add('slide-in');
                await updateHungerCard();
                startTipRotation();
            }
        }

        function hideLegacyHungerCoachCard() {
            const hideHungerCard = document.getElementById('hungerCoachCard');
            if (hideHungerCard) {
                hideHungerCard.classList.add('hidden');
                hideHungerCard.classList.remove('slide-in');
                stopTipRotation();
            }
        }

        async function updateHungerCard() {
            if (!hungerCoach) return;

            const textElement = document.getElementById('hungerCardText');
            const iconElement = document.getElementById('hungerCardIcon');

            if (!textElement || !iconElement) return;

            try {
                // Get contextual tip based on current fast state
                const updateMealtimes = await getUserMealtimes();
                const contextualTip = hungerCoach.getContextualTip(fastStartTime, updateMealtimes);

                // Add fade effect to content that will change
                const messageElement = document.getElementById('hungerCardMessage');
                messageElement.classList.add('fading');

                setTimeout(() => {
                    // Update icon based on tip type and context
                    const icons = {
                        'educational': 'üß†',
                        'action': getActionIcon(contextualTip.text),
                        'motivational': '‚≠ê',
                        'reassurance': 'üçµ'
                    };
                    iconElement.textContent = icons[contextualTip.type] || 'üçµ';

                    // Update message text (inline format)
                    textElement.textContent = contextualTip.text;

                    // Remove fade effect
                    messageElement.classList.remove('fading');
                }, 300);

            } catch (error) {
                console.error('Error updating hunger card:', error);
                textElement.textContent = 'Remember: hunger comes in waves, not constant streams. This feeling will pass.';
                iconElement.textContent = 'üçµ';
            }
        }

        function getActionIcon(tipText) {
            if (tipText.includes('water') || tipText.includes('drink') || tipText.includes('tea')) {
                return 'üíß';
            } else if (tipText.includes('walk') || tipText.includes('movement') || tipText.includes('exercise')) {
                return 'üö∂';
            } else if (tipText.includes('breath') || tipText.includes('meditation') || tipText.includes('mindful')) {
                return 'üßò';
            } else {
                return 'üí™';
            }
        }


        function handleCardTap(event) {
            // Prevent card tap when See More link is clicked
            if (event.target.id === 'hungerSeeMoreLink') {
                return;
            }

            const card = document.getElementById('hungerCoachCard');
            const extendedContent = document.getElementById('hungerCardExtended');
            const extendedText = document.getElementById('hungerExtendedText');

            if (!card || !extendedContent) return;

            const isExpanded = card.classList.contains('expanded');

            if (isExpanded) {
                // Collapse
                extendedContent.style.display = 'none';
                card.classList.remove('expanded');
            } else {
                // Expand with additional context
                const contextualInfo = getExtendedTipContent();
                extendedText.textContent = contextualInfo;

                extendedContent.style.display = 'block';
                card.classList.add('expanded');

                // Add slight bounce animation
                card.style.transform = 'scale(1.02)';
                setTimeout(() => {
                    card.style.transform = '';
                }, 200);
            }
        }

        function getExtendedTipContent() {
            if (!fastStartTime) return 'Keep up the great work with your fast!';

            const fastElapsedHours = (Date.now() - new Date(fastStartTime).getTime()) / (1000 * 60 * 60);

            if (fastElapsedHours < 6) {
                return 'You\'re in the early stages. Your body is still adjusting to the fasting state. Stay hydrated and keep busy.';
            } else if (fastElapsedHours < 12) {
                return 'Your glycogen stores are being depleted. This is when hunger can feel strongest, but it will pass.';
            } else if (elapsedHours < 18) {
                return 'You\'re entering deeper metabolic changes. Many people find hunger actually decreases around this time.';
            } else if (elapsedHours < 24) {
                return 'You\'re approaching or in ketosis. Mental clarity often improves and hunger becomes more manageable.';
            } else {
                return 'You\'re in extended fasting territory. Your body has adapted well. Trust the process and listen to your body.';
            }
        }

        function handleSeeMoreClick(event) {
            // Prevent event bubbling to card tap handler
            event.preventDefault();
            event.stopPropagation();

            // TODO: When learning library is implemented, navigate to hunger management section
            // For now, provide feedback that the feature will be available soon
            console.log('See More clicked - will navigate to learning library');

            // Show temporary feedback
            const seeMoreLink = document.getElementById('hungerSeeMoreLink');
            const originalText = seeMoreLink.textContent;

            seeMoreLink.textContent = 'Coming Soon!';
            seeMoreLink.style.color = '#059669';

            setTimeout(() => {
                seeMoreLink.textContent = originalText;
                seeMoreLink.style.color = '';
            }, 2000);

            // Show next tip to keep engagement
            setTimeout(async () => {
                await updateHungerCard();
            }, 3000);
        }

        // Benefits Card Event Handlers
        function handleBenefitsCardTap(event) {
            // Prevent card tap when See More link is clicked
            if (event.target.id === 'benefitsSeeMoreLink') {
                return;
            }

            const benefitsCard = document.getElementById('benefitsCard');
            const benefitsExtendedContent = document.getElementById('benefitsCardExtended');
            const benefitsExtendedText = document.getElementById('benefitsExtendedText');

            if (!benefitsCard || !benefitsExtendedContent) return;

            // Toggle expanded state
            const benefitsIsExpanded = benefitsCard.classList.contains('expanded');

            if (!benefitsIsExpanded) {
                // Expand the card
                benefitsCard.classList.add('expanded');
                benefitsExtendedContent.style.display = 'block';

                // Update extended content if needed
                if (!benefitsExtendedText.textContent || benefitsExtendedText.textContent === 'Detailed benefits information will appear here when you tap the card.') {
                    updateBenefitsExtendedContent();
                }

                // Notify card rotation manager about user interaction
                if (cardRotationManager) {
                    cardRotationManager.onCardTap('benefits', event);
                }
            } else {
                // Collapse the card
                benefitsCard.classList.remove('expanded');
                benefitsExtendedContent.style.display = 'none';
            }
        }

        function handleBenefitsSeeMoreClick(event) {
            // Prevent event bubbling to card tap handler
            event.preventDefault();
            event.stopPropagation();

            // Navigate to dashboard benefits tab
            window.location.href = '/dashboard#benefits';
        }

        function updateBenefitsExtendedContent() {
            const benefitsExtendedTextElement = document.getElementById('benefitsExtendedText');
            if (!benefitsExtendedTextElement) return;

            // Calculate some quick benefits for display
            const benefitsElapsedHours = Math.floor(getElapsedTime() / (60 * 60 * 1000));
            const estimatedMealsSkipped = Math.floor(benefitsElapsedHours / 8); // Rough estimate
            const estimatedSavings = estimatedMealsSkipped * 10; // $10 per meal estimate

            if (estimatedSavings > 0) {
                benefitsExtendedTextElement.textContent = `So far you've skipped ${estimatedMealsSkipped} meal${estimatedMealsSkipped === 1 ? '' : 's'} and saved approximately $${estimatedSavings}. Visit the Benefits tab in your dashboard for detailed tracking and insights.`;
            } else {
                benefitsExtendedTextElement.textContent = 'Keep going! Your benefits will grow with each meal you skip. Visit the Benefits tab in your dashboard for detailed tracking.';
            }
        }

        function startTipRotation() {
            stopTipRotation(); // Clear any existing interval

            if (hungerCoach && isRunning) {
                tipRotationInterval = setInterval(async () => {
                    await updateHungerCard();
                }, TIP_ROTATION_INTERVAL);
            }
        }

        function stopTipRotation() {
            if (tipRotationInterval) {
                clearInterval(tipRotationInterval);
                tipRotationInterval = null;
            }
        }

        // User mealtimes cache
        let userMealtimes = null;
        let mealtimesLoaded = false;

        async function getUserMealtimes() {
            // Return cached mealtimes if already loaded
            if (mealtimesLoaded && userMealtimes) {
                return userMealtimes;
            }

            const sessionId = window.getSessionId();
            if (!sessionId) {
                // Return defaults if no session
                const sessionDefaults = {
                    breakfast: '08:00',
                    lunch: '12:00',
                    dinner: '18:00'
                };
                userMealtimes = sessionDefaults;
                mealtimesLoaded = true;
                return sessionDefaults;
            }

            try {
                const response = await fetch(`/api/user/${sessionId}/hunger-settings`);
                if (response.ok) {
                    const settings = await response.json();

                    // Convert custom_mealtimes array to object format expected by HungerCoach
                    let settingsMealtimes = {};
                    if (settings.custom_mealtimes && Array.isArray(settings.custom_mealtimes)) {
                        settings.custom_mealtimes.forEach(meal => {
                            // Use meal name as key, but convert to lowercase for consistency
                            const key = meal.name.toLowerCase().replace(/\s+/g, '_');
                            settingsMealtimes[key] = meal.time;
                        });
                    }

                    // Fallback to defaults if no custom mealtimes
                    if (Object.keys(settingsMealtimes).length === 0) {
                        settingsMealtimes = {
                            breakfast: '08:00',
                            lunch: '12:00',
                            dinner: '18:00'
                        };
                    }

                    mealtimesLoaded = true;
                    return settingsMealtimes;
                } else {
                    console.error('Failed to load user mealtimes:', response.status);
                    // Return defaults on failure
                    const fallbackDefaults = {
                        breakfast: '08:00',
                        lunch: '12:00',
                        dinner: '18:00'
                    };
                    userMealtimes = fallbackDefaults;
                    mealtimesLoaded = true;
                    return fallbackDefaults;
                }
            } catch (error) {
                console.error('Error loading user mealtimes:', error);
                // Return defaults on error
                const errorDefaults = {
                    breakfast: '08:00',
                    lunch: '12:00',
                    dinner: '18:00'
                };
                userMealtimes = errorDefaults;
                mealtimesLoaded = true;
                return errorDefaults;
            }
        }

        // Create milestone markers on the outer ring with responsive positioning
        function createMilestoneMarkers() {
            const container = document.getElementById('milestoneMarkers');
            // Clear any existing markers first
            container.innerHTML = '';
            
            // Get the actual current size of the circular timer
            const timerSize = Math.min(280, window.innerWidth * 0.7); // matches min(280px, 70vw)
            const containerRadius = timerSize / 2; // Full container radius
            const progressRingRadius = (timerSize - 20) / 2; // Actual progress ring radius
            
            milestones.forEach(milestone => {
                // Only show milestones that are within the fast duration
                if (milestone.hours <= fastDuration) {
                    const marker = document.createElement('div');
                    marker.className = 'milestone-marker';
                    marker.dataset.hours = milestone.hours;
                    
                    // Calculate position on outer progress ring (12 o'clock = 0¬∞, clockwise)
                    const angle = (milestone.hours / fastDuration) * 360 - 90; // -90 to start at top
                    const radians = (angle * Math.PI) / 180;
                    // Position exactly on the outer progress ring
                    const x = containerRadius + progressRingRadius * Math.cos(radians);
                    const y = containerRadius + progressRingRadius * Math.sin(radians);
                    
                    marker.style.left = x + 'px';
                    marker.style.top = y + 'px';
                    
                    // Add tooltip
                    const tooltip = document.createElement('div');
                    tooltip.className = 'milestone-tooltip';
                    tooltip.innerHTML = `<strong>${milestone.icon} ${milestone.title}</strong><br>${milestone.message}`;
                    
                    // Add click handler to marker
                    marker.addEventListener('click', (e) => {
                        e.stopPropagation();
                        tooltip.classList.add('show');
                        document.body.appendChild(tooltip);
                    });
                    
                    // Add click handler to close tooltip
                    tooltip.addEventListener('click', (e) => {
                        e.stopPropagation();
                        tooltip.classList.remove('show');
                    });
                    
                    // Close tooltip when clicking outside
                    document.addEventListener('click', () => {
                        tooltip.classList.remove('show');
                    });
                    
                    marker.appendChild(tooltip);
                    
                    container.appendChild(marker);
                }
            });
        }


        // Update milestone states based on current progress
        function updateMilestoneStates() {
            const currentElapsedHours = elapsedTime / (1000 * 60 * 60);
            let currentMilestone = null;
            
            document.querySelectorAll('.milestone-marker').forEach(marker => {
                const milestoneHours = parseFloat(marker.dataset.hours);
                marker.classList.remove('reached', 'current');
                
                if (currentElapsedHours >= milestoneHours + 1) {
                    // Milestone completed (1 hour grace period)
                    marker.classList.add('reached');
                } else if (currentElapsedHours >= milestoneHours - 1 && currentElapsedHours < milestoneHours + 1) {
                    // Currently approaching or in milestone window
                    marker.classList.add('current');
                }
                
                // Check if we just reached this milestone
                if (currentElapsedHours >= milestoneHours && currentElapsedHours < milestoneHours + 1) {
                    // Find the milestone data
                    const milestone = milestones.find(m => m.hours === milestoneHours);
                    if (milestone) {
                        currentMilestone = milestone;
                    }
                }
            });
            
            // If we have a current milestone and it's different from the last one, update the display
            if (currentMilestone && currentMilestone !== lastReachedMilestone) {
                lastReachedMilestone = currentMilestone;
                updatePhaseInfoWithMilestone(currentMilestone);
            } else if (!currentMilestone && lastReachedMilestone) {
                // No current milestone, return to regular phase info
                lastReachedMilestone = null;
                const phaseElapsedHours = Math.floor(elapsedTime / (1000 * 60 * 60));
                updatePhaseInfo(phaseElapsedHours);
            } else if (!currentMilestone && !lastReachedMilestone) {
                // No milestone active, show regular phase info
                const regularPhaseHours = Math.floor(elapsedTime / (1000 * 60 * 60));
                updatePhaseInfo(regularPhaseHours);
            }
        }
        // Toggle duration selector visibility
        function toggleDurationSelector() {
            const selector = document.getElementById('durationSelector');
            const isVisible = selector.style.display !== 'none';
            
            if (isVisible) {
                selector.style.display = 'none';
            } else {
                selector.style.display = 'block';
            }
            
            // Update sticky button visibility when selector is toggled
            setTimeout(updateStickyButtonVisibility, 50); // Small delay to let display change take effect
        }
        
        // Select a preset duration
        function selectDuration(hours, options = {}) {
            const { userInitiated = true } = options;
            const normalizedHours = Math.max(1, Math.round(Number(hours) || 0));
            selectedDuration = normalizedHours;

            if (userInitiated) {
                hasUserAdjustedDuration = normalizedHours !== autoSelectedDuration;
                if (hasUserAdjustedDuration) {
                    durationResolver?.markManualSelection();
                } else {
                    durationResolver?.clearManualSelection?.();
                }
            } else if (normalizedHours === autoSelectedDuration) {
                hasUserAdjustedDuration = false;
                durationResolver?.clearManualSelection?.();
            }

            // Update active state on buttons
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.classList.remove('active', 'selected-confirmation');
            });

            const selectedBtn = document.querySelector(`[data-hours="${normalizedHours}"]`);
            if (selectedBtn) {
                selectedBtn.classList.add('active');

                if (userInitiated) {
                    selectedBtn.classList.add('selected-confirmation');
                    setTimeout(() => {
                        selectedBtn.classList.remove('selected-confirmation');
                    }, 1200);
                }

                // Clear custom input when using presets
                document.getElementById('customHours').value = '';
            }

            // Update start button text
            updateStartButtonText();

            // Update sticky button visibility
            updateStickyButtonVisibility();
        }

        // Apply custom duration
        function applyCustomDuration() {
            const customInput = document.getElementById('customHours');
            const customHours = parseInt(customInput.value);
            
            // Validation
            if (isNaN(customHours) || customHours < 1 || customHours > 168) {
                alert('Please enter a valid duration between 1 and 168 hours.');
                return;
            }
            
            selectedDuration = customHours;
            hasUserAdjustedDuration = true;
            durationResolver?.markManualSelection();
            
            // Remove active state from preset buttons
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Update start button text
            updateStartButtonText();
            
            // Update sticky button visibility
            updateStickyButtonVisibility();
        }
        
        // Toggle start time inputs visibility
        function toggleStartTimeInputs() {
            const startTimeRadios = document.querySelectorAll('input[name="startTime"]');
            const timeInputGroup = document.getElementById('timeInputGroup');
            const isCustomTime = Array.from(startTimeRadios).find(r => r.checked)?.value === 'custom';
            
            if (isCustomTime) {
                timeInputGroup.style.display = 'flex';
                // Set default to current time if not already set
                const startTimeInput = document.getElementById('startTimeInput');
                if (!startTimeInput.value) {
                    const currentTime = new Date();
                    startTimeInput.value = currentTime.toTimeString().slice(0, 5); // HH:MM format
                }
            } else {
                timeInputGroup.style.display = 'none';
                selectedStartTime = null;
            }
            
            updateSelectedStartTime();
            updateStartButtonText();
        }
        
        // Update selected start time based on inputs
        function updateSelectedStartTime() {
            const modeRadios = document.querySelectorAll('input[name="startTime"]');
            const selectedMode = Array.from(modeRadios).find(r => r.checked)?.value;
            
            if (selectedMode === 'now') {
                selectedStartTime = null;
            } else if (selectedMode === 'custom') {
                const customTimeInput = document.getElementById('startTimeInput');
                const dateOffset = parseInt(document.getElementById('startDateOffset').value);
                
                if (customTimeInput.value) {
                    const nowTime = new Date();
                    const [hours, minutes] = customTimeInput.value.split(':').map(Number);
                    
                    // Create date with selected time
                    const selectedDate = new Date(nowTime);
                    selectedDate.setHours(hours, minutes, 0, 0);
                    
                    // Apply date offset (0 = today, 1 = yesterday)
                    selectedDate.setDate(selectedDate.getDate() - dateOffset);
                    
                    // Validate - can't be in the future or more than 7 days ago
                    const maxBackdate = new Date(nowTime.getTime() - (7 * 24 * 60 * 60 * 1000)); // 7 days ago
                    
                    if (selectedDate > nowTime) {
                        selectedStartTime = null;
                        alert('Start time cannot be in the future!');
                        customTimeInput.value = '';
                    } else if (selectedDate < maxBackdate) {
                        selectedStartTime = null;
                        alert('Start time cannot be more than 7 days ago!');
                        customTimeInput.value = '';
                    } else {
                        selectedStartTime = selectedDate;
                    }
                }
            }
        }
        
        // Update start button text based on selected duration and start time
        function updateStartButtonText() {
            const btn = document.getElementById('startFastBtn');
            const stickyBtn = document.getElementById('stickyStartBtn');
            const stickyBtnText = document.getElementById('stickyBtnText');
            const stickyBtnBadge = document.getElementById('stickyBtnBadge');
            const usingRecommendedDuration = selectedDuration === autoSelectedDuration;
            const actionableScheduled = isScheduledFastActionable && usingRecommendedDuration && !selectedStartTime;
            const scheduledStatus = scheduledFastContext?.status;
            
            if (selectedStartTime) {
                const startTimeStr = selectedStartTime.toLocaleTimeString('en-US', {
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true
                });
                btn.textContent = `Resume ${selectedDuration}h Fast (started ${startTimeStr})`;
                stickyBtnText.textContent = `Resume ${selectedDuration}h Fast`;
                stickyBtnBadge.textContent = `Started: ${startTimeStr}`;
            } else if (actionableScheduled) {
                const isRecent = scheduledStatus === 'actionable_recent';
                const primaryLabel = isRecent ? 'Start Today\'s Scheduled Fast' : 'Start Scheduled Fast';
                btn.textContent = `${primaryLabel} (${selectedDuration}h)`;
                stickyBtnText.textContent = primaryLabel;
                stickyBtnBadge.textContent = `Scheduled: ${selectedDuration} hours`;
            } else {
                btn.textContent = `Start ${selectedDuration}h Fast`;
                stickyBtnText.textContent = `Start ${selectedDuration}h Fast`;
                stickyBtnBadge.textContent = `Selected: ${selectedDuration} hours`;
            }
        }
        
        // Update sticky button visibility based on scroll position and duration selection
        function updateStickyButtonVisibility() {
            const mainButton = document.getElementById('startFastBtn');
            const stickyButton = document.getElementById('stickyStartBtn');
            const durationSelector = document.getElementById('durationSelector');
            
            // Only show sticky button if:
            // 1. Duration selector is visible (user is customizing)
            // 2. A preset duration was selected (not default 24h)
            // 3. Main button is not visible in viewport
            
            if (!mainButton || !stickyButton || !durationSelector) return;
            
            const mainButtonRect = mainButton.getBoundingClientRect();
            const isMainButtonVisible = mainButtonRect.top >= 0 && mainButtonRect.bottom <= window.innerHeight;
            const isDurationSelectorVisible = durationSelector.style.display !== 'none';
            const hasCustomDuration = selectedStartTime !== null || selectedDuration !== autoSelectedDuration;
            
            // Show sticky button when main button is not visible AND user has made a selection
            if (!isMainButtonVisible && isDurationSelectorVisible && hasCustomDuration) {
                stickyButton.style.display = 'block';
            } else {
                stickyButton.style.display = 'none';
            }
        }
        
        // Toggle start time adjustment controls
        function toggleStartTimeAdjustment() {
            const toggleAdjustmentRow = document.getElementById('startTimeAdjustment');
            const toggleAdjustBtn = document.getElementById('adjustStartBtn');
            
            if (toggleAdjustmentRow.style.display === 'none') {
                // Show adjustment controls
                toggleAdjustmentRow.style.display = 'block';
                toggleAdjustBtn.textContent = 'cancel';
                
                // Pre-populate with current start time
                const toggleTimeInput = document.getElementById('adjustTimeInput');
                const toggleDateOffset = document.getElementById('adjustDateOffset');
                
                toggleTimeInput.value = fastStartTime.toTimeString().slice(0, 5); // HH:MM
                
                // Calculate date offset
                const adjustToday = new Date();
                adjustToday.setHours(0, 0, 0, 0);
                const startDate = new Date(fastStartTime);
                startDate.setHours(0, 0, 0, 0);
                const daysDiff = Math.floor((adjustToday - startDate) / (24 * 60 * 60 * 1000));
                
                toggleDateOffset.value = Math.min(daysDiff, 2); // Cap at 2 days ago
            } else {
                // Hide adjustment controls
                cancelStartTimeAdjustment();
            }
        }
        
        // Apply start time adjustment
        async function applyStartTimeAdjustment() {

            const adjustTimeInput = document.getElementById('adjustTimeInput');
            const adjustDateOffset = document.getElementById('adjustDateOffset');

            if (!adjustTimeInput.value) {
                alert('Please enter a start time.');
                return;
            }

            // Calculate new start time
            const adjustmentTime = new Date();
            const [hours, minutes] = adjustTimeInput.value.split(':').map(Number);
            const adjustmentDateOffset = parseInt(adjustDateOffset.value);

            const newStartTime = new Date(adjustmentTime);
            newStartTime.setHours(hours, minutes, 0, 0);
            newStartTime.setDate(newStartTime.getDate() - adjustmentDateOffset);

            // Validation
            const adjustmentMaxBackdate = new Date(adjustmentTime.getTime() - (7 * 24 * 60 * 60 * 1000));

            if (newStartTime > adjustmentTime) {
                alert('Start time cannot be in the future!');
                return;
            } else if (newStartTime < adjustmentMaxBackdate) {
                alert('Start time cannot be more than 7 days ago!');
                return;
            }

            // Update the fast start time
            fastStartTime = newStartTime;
            elapsedTime = Date.now() - fastStartTime.getTime();

            // Update database if we have an active fast
            let databaseUpdateSuccessful = false;

            // Ensure we have currentFastId - try to get it if missing
            if (!currentFastId) {
                const timerState = localStorage.getItem('fastingForecast_timerState');
                if (timerState) {
                    try {
                        const parsedState = JSON.parse(timerState);
                        currentFastId = parsedState.currentFastId;
                        console.log('Retrieved currentFastId from localStorage:', currentFastId);
                    } catch (e) {
                        console.error('Error parsing timer state:', e);
                    }
                }
            }

            if (currentFastId) {
                try {
                    const updateSessionId = window.getSessionId();
                    if (!updateSessionId) {
                        throw new Error('Session not available');
                    }

                    const updateResponse = await fetch(`/api/fasts/${currentFastId}?sessionId=${updateSessionId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ start_time: fastStartTime.toISOString() })
                    });

                    if (!updateResponse.ok) {
                        const errorData = await updateResponse.json();
                        throw new Error(`Server error: ${errorData.error || 'Unknown error'}`);
                    }

                    databaseUpdateSuccessful = true;
                } catch (error) {
                    console.error('Failed to update start time in database:', error);
                    alert('Warning: Start time updated locally but may not persist. Please try again or refresh the page.');
                }
            } else {
                console.warn('No active fast ID available - changes will not persist');
                alert('Warning: No active fast found. Changes may not persist.');
            }

            // Update localStorage with new state
            const adjustedTimerState = {
                fastStartTime: fastStartTime.toISOString(),
                fastDuration: fastDuration,
                isActive: true,
                currentFastId: currentFastId
            };
            localStorage.setItem('fastingForecast_timerState', JSON.stringify(adjustedTimerState));

            // Update other components (notifications, cards, etc.)
            try {
                if (globalNotificationManager) {
                    globalNotificationManager.stopNotificationsForFast();
                    await globalNotificationManager.startNotificationsForFast(fastStartTime, fastDuration);
                }

                if (cardRotationManager) {
                    const cardMealtimes = await getUserMealtimes();
                    cardRotationManager.updateFastState(isRunning, fastStartTime, cardMealtimes);
                } else if (hungerCoach) {
                    await updateHungerCard();
                }
            } catch (error) {
                console.error('Error updating components:', error);
            }

            // Update UI - this should always happen
            updateTimeDisplay();
            updateTimerDisplay();
            updateMilestoneStates();
            cancelStartTimeAdjustment();

            console.log('Start time adjustment completed:', databaseUpdateSuccessful ? 'saved to database' : 'local only');
        }

        // Ensure function is globally available
        window.applyStartTimeAdjustment = applyStartTimeAdjustment;
        
        // Cancel start time adjustment
        function cancelStartTimeAdjustment() {
            const cancelAdjustmentRow = document.getElementById('startTimeAdjustment');
            const cancelAdjustBtn = document.getElementById('adjustStartBtn');
            
            cancelAdjustmentRow.style.display = 'none';
            cancelAdjustBtn.innerHTML = '<small>adjust</small>';
        }
        
        // Start a fast
        async function startFast() {
            if (shouldUseScheduledStart()) {
                const scheduledInstanceId = scheduledFastContext?.actionableInstance?.id;
                if (scheduledInstanceId) {
                    const started = await startScheduledFast(scheduledInstanceId);
                    if (started) {
                        return;
                    }
                    console.warn('Scheduled fast start failed, falling back to manual start');
                }
            }

            // Use selected duration for this fast
            fastDuration = selectedDuration;
            
            // Hide duration selector
            document.getElementById('durationSelector').style.display = 'none';
            
            document.getElementById('preFastState').style.display = 'none';
            document.getElementById('activeFastState').style.display = 'block';
            document.querySelector('.welcome-message').style.display = 'none';
            
            isRunning = true;
            // Always use current time for "Start now", enforce selected time for custom start
            if (selectedStartTime) {
                fastStartTime = selectedStartTime;
                elapsedTime = Date.now() - selectedStartTime.getTime();
                console.log('Starting fast with custom start time:', fastStartTime);
            } else {
                fastStartTime = new Date();
                elapsedTime = 0;
                console.log('Starting fast now at:', fastStartTime);
            }
            
            // Create fast entry in database
            await createFastEntry();
            
            // Save timer state to localStorage for persistence across navigation
            const newTimerState = {
                isRunning: true,
                fastStartTime: fastStartTime.toISOString(),
                fastDuration: fastDuration,
                currentFastId: currentFastId
            };
            localStorage.setItem('fastingForecast_timerState', JSON.stringify(newTimerState));
            
            // Create milestone markers
            createMilestoneMarkers();

            // Initialize phase banner
            if (!phaseBanner) {
                initializePhaseBanner();
            }

            // Initialize and show contextual cards
            if (!cardRotationManager) {
                await initializeCardRotationManager();
            }
            await showContextualCards();

            // Start global notifications for the fast
            if (globalNotificationManager) {
                await globalNotificationManager.startNotificationsForFast(fastStartTime, fastDuration);
            }
            
            // Set start and end times
            updateTimeDisplay();
            
            // Initial display update
            updateTimerDisplay();
            
            // If backdated, immediately update milestone states to reflect elapsed time
            if (selectedStartTime) {
                updateMilestoneStates();
            }
            
            // Start the timer interval
            console.log('Starting timer interval - fastStartTime:', fastStartTime);
            timerInterval = setInterval(() => {
                const newElapsedTime = Date.now() - fastStartTime.getTime();
                elapsedTime = newElapsedTime;
                updateTimerDisplay();
            }, 1000);
        }
        
        // End a fast
        async function endFast() {
            if (isRunning) {
                clearInterval(timerInterval);
                isRunning = false;

                // Hide contextual cards and stop global notifications
                hideContextualCards();
                if (globalNotificationManager) {
                    globalNotificationManager.stopNotificationsForFast();
                }

                // End fast entry in database
                await endFastEntry();

                // Clear timer state from localStorage
                localStorage.removeItem('fastingForecast_timerState');
            }
            
            // Show completion state instead of going back to pre-fast
            showFastCompletion();
        }
        
        // Update timer display with elapsed/remaining logic
        function updateTimerDisplay() {
            const totalFastDuration = fastDuration * 60 * 60 * 1000; // Convert hours to milliseconds
            const remainingTime = Math.max(0, totalFastDuration - elapsedTime);
            const isShowingElapsed = elapsedTime <= totalFastDuration / 2;
            const isPastOriginalGoal = elapsedTime > totalFastDuration;
            
            let displayTime, label;
            
            if (isPastOriginalGoal) {
                // Past original goal - always show total elapsed time
                displayTime = elapsedTime;
                label = 'EXTENDED FAST';
            } else if (isShowingElapsed) {
                displayTime = elapsedTime;
                label = 'ELAPSED';
            } else {
                displayTime = remainingTime;
                label = 'REMAINING';
            }
            
            const hours = Math.floor(displayTime / (1000 * 60 * 60));
            const minutes = Math.floor((displayTime % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((displayTime % (1000 * 60)) / 1000);
            
            // Show seconds for first hour, then switch to HH:MM
            const showSeconds = elapsedTime < (60 * 60 * 1000); // First 60 minutes
            
            const formattedTime = showSeconds
                ? `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`
                : `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;

            document.getElementById('timerDisplay').textContent = formattedTime;
            
            document.getElementById('timerLabel').textContent = label;
            
            // Update triple-layer circular progress
            
            // Outer circle: Overall fast progress (24 hours)
            const overallProgressPercent = Math.min(100, (elapsedTime / totalFastDuration) * 100);
            const overallProgressDegrees = (overallProgressPercent / 100) * 360;
            document.getElementById('timerProgressOuter').style.background = 
                `conic-gradient(#ec4899 ${overallProgressDegrees}deg, #f0f0f0 ${overallProgressDegrees}deg)`;
            
            // Inner circle: Current hour progress (resets every hour)
            const millisecondsInHour = 60 * 60 * 1000;
            const currentHourProgress = (elapsedTime % millisecondsInHour) / millisecondsInHour;
            const hourProgressDegrees = currentHourProgress * 360;
            document.getElementById('timerProgressInner').style.background = 
                `conic-gradient(#fb923c ${hourProgressDegrees}deg, #f8f9fa ${hourProgressDegrees}deg)`;
            
            // Innermost circle: First minute and last minute logic
            const minuteElement = document.getElementById('timerProgressMinute');
            const radarPulse = document.getElementById('radarPulse');
            const millisecondsInMinute = 60 * 1000;
            // Use the remainingTime already calculated above
            
            if (elapsedTime <= millisecondsInMinute) {
                // First minute: Show progress and fade out pulse
                const minuteProgress = elapsedTime / millisecondsInMinute;
                const minuteProgressDegrees = minuteProgress * 360;
                
                minuteElement.classList.add('visible');
                minuteElement.style.background = 
                    `conic-gradient(#fcd34d ${minuteProgressDegrees}deg, #f8f9fa ${minuteProgressDegrees}deg)`;
                
                // Show radar pulse with fade out intensity over the minute (strong to weak)
                // Use a slower fade curve: stays strong until 75% through, then fades to 30%
                const firstMinutePulseIntensity = minuteProgress < 0.75 ? 
                    1 - (minuteProgress * 0.3) :  // Slow fade from 1.0 to 0.7 over first 75%
                    0.7 - ((minuteProgress - 0.75) / 0.25) * 0.4; // Faster fade from 0.7 to 0.3 over last 25%
                
                radarPulse.classList.add('visible');
                radarPulse.style.setProperty('--pulse-opacity', Math.max(0.3, firstMinutePulseIntensity));
                
            } else if (remainingTime <= millisecondsInMinute && remainingTime > 0) {
                // Last minute: Show progress and fade in pulse
                const lastMinuteProgress = (millisecondsInMinute - remainingTime) / millisecondsInMinute;
                const lastMinuteProgressDegrees = lastMinuteProgress * 360;
                
                minuteElement.classList.add('visible');
                minuteElement.style.background = 
                    `conic-gradient(#fcd34d ${lastMinuteProgressDegrees}deg, #f8f9fa ${lastMinuteProgressDegrees}deg)`;
                
                // Show radar pulse with fade in intensity over the last minute (weak to strong)
                // Start at 30% and build to full intensity more gradually
                const lastMinutePulseIntensity = lastMinuteProgress < 0.25 ? 
                    0.3 + (lastMinuteProgress / 0.25) * 0.4 : // Slow build from 0.3 to 0.7 over first 25%
                    0.7 + ((lastMinuteProgress - 0.25) / 0.75) * 0.3; // Build from 0.7 to 1.0 over last 75%
                    
                radarPulse.classList.add('visible');
                radarPulse.style.setProperty('--pulse-opacity', Math.min(1.0, lastMinutePulseIntensity));
                
            } else {
                // Hide minute ring and pulse during middle period
                minuteElement.classList.remove('visible');
                radarPulse.classList.remove('visible');
            }
            
            // Update milestone states and phase info
            updateMilestoneStates();
        }
        
        // Update start and end time display
        function updateTimeDisplay() {
            if (!fastStartTime) return;

            console.log('updateTimeDisplay called with fastStartTime:', fastStartTime);
            console.log('fastStartTime UTC string:', fastStartTime.toISOString());
            console.log('fastStartTime local string:', fastStartTime.toString());

            const displayStartTime = fastStartTime;
            const displayEndTime = new Date(fastStartTime.getTime() + (fastDuration * 60 * 60 * 1000));
            
            const formatDateTime = (date) => {
                const timeStr = date.toLocaleTimeString('en-US', { 
                    hour: 'numeric', 
                    minute: '2-digit',
                    hour12: true 
                });
                
                // Check if it's a different day to show date
                const today = new Date();
                const isToday = date.toDateString() === today.toDateString();
                const isTomorrow = date.toDateString() === new Date(today.getTime() + 24 * 60 * 60 * 1000).toDateString();
                
                if (isToday) {
                    return timeStr + ' (Today)';
                } else if (isTomorrow) {
                    return timeStr + ' (Tomorrow)';
                } else {
                    // Show abbreviated date for other days
                    const dateStr = date.toLocaleDateString('en-US', { 
                        month: 'short', 
                        day: 'numeric' 
                    });
                    return timeStr + ' (' + dateStr + ')';
                }
            };
            
            const formattedStartTime = formatDateTime(displayStartTime);
            const formattedEndTime = formatDateTime(displayEndTime);

            console.log('Setting start time display to:', formattedStartTime);
            console.log('Setting end time display to:', formattedEndTime);

            document.getElementById('startTime').textContent = formattedStartTime;
            document.getElementById('endTime').textContent = formattedEndTime;

            console.log('DOM startTime element now shows:', document.getElementById('startTime').textContent);
        }
        
        // Update phase information based on elapsed hours
        function updatePhaseInfo(hours) {
            let currentPhase = phases[0];

            // Find the appropriate phase
            for (const phaseHour in phases) {
                if (hours >= parseInt(phaseHour)) {
                    currentPhase = phases[phaseHour];
                }
            }

            // Update phase banner if available
            if (phaseBanner) {
                phaseBanner.updatePhase(currentPhase);
            } else {
                // Fallback to direct DOM manipulation if banner not initialized
                const phaseTextElement = document.getElementById('phaseText');
                const phaseDescElement = document.getElementById('phaseDescription');
                if (phaseTextElement) phaseTextElement.textContent = currentPhase.title;
                if (phaseDescElement) phaseDescElement.textContent = currentPhase.description;
            }
        }

        // Update phase info container with milestone details
        function updatePhaseInfoWithMilestone(milestone) {
            // Update phase banner if available
            if (phaseBanner) {
                phaseBanner.updateMilestone(milestone);
            } else {
                // Fallback to direct DOM manipulation if banner not initialized
                const phaseTextElement = document.getElementById('phaseText');
                const phaseDescElement = document.getElementById('phaseDescription');
                const phaseIconElement = document.querySelector('.phase-icon');
                if (phaseTextElement) phaseTextElement.textContent = milestone.title;
                if (phaseDescElement) phaseDescElement.textContent = milestone.message;
                if (phaseIconElement) phaseIconElement.textContent = milestone.icon;
            }
        }
        
        
        
        // Reset timer
        function resetTimer() {
            console.log('üö® resetTimer() called - currentFastId:', currentFastId, 'isRunning:', isRunning);

            // Don't reset if we have an active fast that was just restored
            if (currentFastId && isRunning) {
                console.log('üö® BLOCKED resetTimer() - active fast detected, ignoring reset request');
                return;
            }

            if (isRunning) {
                clearInterval(timerInterval);
                isRunning = false;
            }
            
            // Clear milestone markers
            document.getElementById('milestoneMarkers').innerHTML = '';
            
            // Reset milestone tracking
            lastReachedMilestone = null;
            
            // Reset start time selection
            selectedStartTime = null;
            document.querySelector('input[name="startTime"][value="now"]').checked = true;
            document.getElementById('timeInputGroup').style.display = 'none';
            document.getElementById('startTimeInput').value = '';
            
            // Hide adjustment controls
            cancelStartTimeAdjustment();
            
            // Hide duration selector
            document.getElementById('durationSelector').style.display = 'none';
            
            // Reset to pre-fast state
            document.getElementById('activeFastState').style.display = 'none';
            document.getElementById('preFastState').style.display = 'block';
            document.querySelector('.welcome-message').style.display = 'block';
            
            elapsedTime = 0;
            fastStartTime = null;
            
            // Clear timer state from localStorage
            localStorage.removeItem('fastingForecast_timerState');
        }
        
        // Load saved stats from API
        async function loadStats() {
            try {
                const loadStatsSessionId = window.getSessionId();
                if (!loadStatsSessionId) {
                    document.getElementById('totalFasts').textContent = '0';
                    document.getElementById('longestFast').textContent = '0h';
                    return;
                }
                
                // Fetch all completed fasts for this user
                const statsResponse = await fetch(`/api/fasts?sessionId=${loadStatsSessionId}&limit=1000`);
                if (statsResponse.ok) {
                    const statsFasts = await statsResponse.json();
                    
                    // Filter for completed fasts only (those with end_time)
                    const completedFasts = statsFasts.filter(fast => fast.end_time);
                    
                    // Calculate total completed fasts
                    const totalFasts = completedFasts.length;
                    document.getElementById('totalFasts').textContent = totalFasts.toString();
                    
                    // Calculate longest fast duration
                    let longestDuration = 0;
                    completedFasts.forEach(fast => {
                        let duration = 0;
                        
                        // Use stored duration_hours if available, otherwise calculate it
                        if (fast.duration_hours && fast.duration_hours > 0) {
                            duration = fast.duration_hours;
                        } else if (fast.start_time && fast.end_time) {
                            // Fallback calculation if duration_hours is missing or zero
                            const fastRecordStartTime = new Date(fast.start_time);
                            const fastEndTime = new Date(fast.end_time);
                            duration = (fastEndTime - fastRecordStartTime) / (1000 * 60 * 60); // Convert to hours
                        }
                        
                        if (duration > longestDuration) {
                            longestDuration = duration;
                        }
                    });
                    
                    // Format longest duration for display
                    let longestDisplayText = '0h';
                    if (longestDuration > 0) {
                        const days = Math.floor(longestDuration / 24);
                        const remainingHours = Math.floor(longestDuration % 24);
                        
                        if (days > 0) {
                            longestDisplayText = days === 1 ? '1 day' : `${days} days`;
                            if (remainingHours > 0) {
                                longestDisplayText += ` ${remainingHours}h`;
                            }
                        } else {
                            longestDisplayText = `${remainingHours}h`;
                        }
                    }
                    
                    document.getElementById('longestFast').textContent = longestDisplayText;
                } else {
                    // Fallback to defaults if API call fails
                    document.getElementById('totalFasts').textContent = '0';
                    document.getElementById('longestFast').textContent = '0h';
                }
            } catch (error) {
                console.error('Error loading stats:', error);
                // Fallback to defaults if there's an error
                document.getElementById('totalFasts').textContent = '0';
                document.getElementById('longestFast').textContent = '0h';
            }
        }
        
        // Initialize user state and determine what to show
        async function initializeUserState() {
            try {
                const initSessionId = window.getSessionId();
                
                if (initSessionId) {
                    // Check if user has any fasts in database
                    const initResponse = await fetch(`/api/fasts?sessionId=${initSessionId}&limit=1`);
                    if (initResponse.ok) {
                        const initFasts = await initResponse.json();
                        
                        if (initFasts.length === 0) {
                            // New user - show welcome state
                            showNewUserWelcome();
                        } else {
                            // User has completed fasts - check if they have actual scheduled fasts
                            await checkUserScheduleStatus(initSessionId);
                        }
                    } else {
                        // API error - default to new user welcome
                        showNewUserWelcome();
                    }
                } else {
                    // No session ID - definitely new user
                    showNewUserWelcome();
                }
            } catch (error) {
                console.error('Error checking user state:', error);
                // Default to new user welcome on error
                showNewUserWelcome();
            }
        }
        
        function showNewUserWelcome() {
            document.getElementById('newUserWelcome').style.display = 'block';
            document.getElementById('scheduleSetupState').style.display = 'none';
            document.getElementById('scheduledFastInfo').style.display = 'none';
            document.getElementById('newUserHint').style.display = 'block';
            
            // Show main start button
            document.getElementById('startFastBtn').style.display = 'block';
            
            // Update button text for new users
            const draftDuration = timerOnboardingController?.draft?.protocol?.durationHours;
            if (draftDuration) {
                document.getElementById('startFastBtn').textContent = `Start ${draftDuration}h Fast`;
            } else {
                document.getElementById('startFastBtn').textContent = 'Start Your First Fast';
            }
        }
        
        function showScheduleSetupState() {
            document.getElementById('newUserWelcome').style.display = 'none';
            document.getElementById('scheduleSetupState').style.display = 'block';
            document.getElementById('scheduledFastInfo').style.display = 'none';
            document.getElementById('newUserHint').style.display = 'none';
            
            // Keep main start button visible as primary action
            document.getElementById('startFastBtn').style.display = 'block';
            document.getElementById('startFastBtn').textContent = 'Start Fast Now';
        }
        
        async function showScheduledFastState() {
            document.getElementById('newUserWelcome').style.display = 'none';
            document.getElementById('scheduleSetupState').style.display = 'none';
            document.getElementById('scheduledFastInfo').style.display = 'block';
            document.getElementById('newUserHint').style.display = 'none';

            // Show main start button
            document.getElementById('startFastBtn').style.display = 'block';

            // Update button text for users with schedules
            document.getElementById('startFastBtn').textContent = `Start ${selectedDuration}h Fast`;

            // Load actual scheduled fast data
            await loadNextScheduledFast();
        }

        // Helper function to format relative date display
        function formatRelativeDate(targetDate) {
            const currentTimestamp = new Date();
            const todayDate = new Date(currentTimestamp.getFullYear(), currentTimestamp.getMonth(), currentTimestamp.getDate());
            const targetDateOnly = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate());

            const diffTime = targetDateOnly.getTime() - todayDate.getTime();
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

            const formattedTime = targetDate.toLocaleTimeString('en-US', {
                hour: 'numeric',
                minute: '2-digit',
                hour12: true
            });

            if (diffDays === 0) {
                return `Today at ${formattedTime}`;
            } else if (diffDays === 1) {
                return `Tomorrow at ${formattedTime}`;
            } else if (diffDays > 1 && diffDays <= 7) {
                const dayOfWeek = targetDate.toLocaleDateString('en-US', { weekday: 'long' });
                return `${dayOfWeek} at ${formattedTime}`;
            } else {
                const nextDayOfWeek = targetDate.toLocaleDateString('en-US', { weekday: 'long' });
                return `Next ${nextDayOfWeek} at ${formattedTime}`;
            }
        }

        function deriveScheduledFastContext(windowData) {
            const context = {
                status: 'none',
                actionableInstance: null,
                upcoming: windowData?.upcoming || null,
                recent: windowData?.recent || null
            };

            if (!windowData) {
                return context;
            }

            const now = new Date();
            const sixHoursMs = 6 * 60 * 60 * 1000;
            const twelveHoursMs = 12 * 60 * 60 * 1000;

            if (windowData.recent?.start_at_utc) {
                const recentStart = new Date(windowData.recent.start_at_utc);
                if (recentStart <= now && (now - recentStart) <= sixHoursMs) {
                    context.status = 'actionable_recent';
                    context.actionableInstance = windowData.recent;
                    return context;
                }
            }

            if (windowData.upcoming?.start_at_utc) {
                const upcomingStart = new Date(windowData.upcoming.start_at_utc);
                const diff = upcomingStart.getTime() - now.getTime();

                if (diff >= 0 && diff <= twelveHoursMs) {
                    context.status = 'actionable_upcoming';
                    context.actionableInstance = windowData.upcoming;
                } else if (diff > twelveHoursMs) {
                    context.status = 'future';
                    context.actionableInstance = windowData.upcoming;
                }
            }

            return context;
        }

        function formatTimeUntil(targetDate, currentDate = new Date()) {
            const diffMs = targetDate.getTime() - currentDate.getTime();
            if (diffMs <= 0) {
                return 'now';
            }

            const totalMinutes = Math.round(diffMs / (1000 * 60));
            if (totalMinutes < 60) {
                const minutes = Math.max(totalMinutes, 1);
                return `${minutes} minute${minutes === 1 ? '' : 's'}`;
            }

            const totalHours = Math.round(totalMinutes / 60);
            if (totalHours < 24) {
                return `${totalHours} hour${totalHours === 1 ? '' : 's'}`;
            }

            const totalDays = Math.round(totalHours / 24);
            return `${totalDays} day${totalDays === 1 ? '' : 's'}`;
        }

        function formatTimeSince(targetDate, currentDate = new Date()) {
            const diffMs = currentDate.getTime() - targetDate.getTime();
            if (diffMs <= 0) {
                return 'moments';
            }

            const totalMinutes = Math.round(diffMs / (1000 * 60));
            if (totalMinutes < 60) {
                const minutes = Math.max(totalMinutes, 1);
                return `${minutes} minute${minutes === 1 ? '' : 's'}`;
            }

            const totalHours = Math.round(totalMinutes / 60);
            if (totalHours < 24) {
                return `${totalHours} hour${totalHours === 1 ? '' : 's'}`;
            }

            const totalDays = Math.round(totalHours / 24);
            return `${totalDays} day${totalDays === 1 ? '' : 's'}`;
        }

        function updateScheduledFastCard(windowData) {
            const card = document.getElementById('scheduledFastInfo');
            const detailsEl = document.getElementById('scheduledFastDetails');
            if (!card || !detailsEl) {
                return;
            }

            const titleEl = card.querySelector('.scheduled-title');
            const hintEl = card.querySelector('.scheduled-info small');

            card.classList.remove('scheduled-actionable', 'scheduled-recent');

            if (!windowData || (!windowData.upcoming && !windowData.recent)) {
                if (detailsEl) {
                    detailsEl.textContent = 'No upcoming fasts scheduled';
                }
                if (titleEl) {
                    titleEl.textContent = 'üóìÔ∏è Next Scheduled Fast';
                }
                if (hintEl) {
                    hintEl.textContent = 'Tap to modify schedule';
                }
                return;
            }

            const context = scheduledFastContext || deriveScheduledFastContext(windowData);
            const now = new Date();
            const displayInstance = context.actionableInstance || windowData.upcoming || windowData.recent;

            if (!displayInstance || !displayInstance.start_at_utc) {
                detailsEl.textContent = 'Schedule unavailable';
                if (titleEl) {
                    titleEl.textContent = 'üóìÔ∏è Next Scheduled Fast';
                }
                if (hintEl) {
                    hintEl.textContent = 'Tap to modify schedule';
                }
                return;
            }

            const start = new Date(displayInstance.start_at_utc);
            const durationText = displayInstance.duration_hours === 24
                ? '24-hour fast'
                : `${displayInstance.duration_hours}-hour fast`;

            let descriptor = formatRelativeDate(start);
            let titleText = 'üóìÔ∏è Next Scheduled Fast';
            let hintText = 'Tap to modify schedule';
            let primaryLine = `${descriptor} ‚Ä¢ ${durationText}`;
            let supplementaryLine = '';

            switch (context.status) {
                case 'actionable_upcoming': {
                    const timeUntil = formatTimeUntil(start, now);
                    card.classList.add('scheduled-actionable');
                    titleText = 'üöÄ Upcoming Scheduled Fast';
                    hintText = 'Use the start button below to begin when ready';
                    primaryLine = `${descriptor} ‚Ä¢ ${durationText} ‚Ä¢ starts in ${timeUntil}`;
                    break;
                }
                case 'actionable_recent': {
                    const timeSince = formatTimeSince(start, now);
                    card.classList.add('scheduled-recent');
                    titleText = '‚è∞ Scheduled Fast Reminder';
                    primaryLine = `Today's scheduled fast was set for ${start.toLocaleTimeString('en-US', {
                        hour: 'numeric',
                        minute: '2-digit',
                        hour12: true
                    })} ‚Ä¢ started ${timeSince} ago`;
                    if (context.upcoming && context.upcoming.id !== displayInstance.id) {
                        const nextStart = new Date(context.upcoming.start_at_utc);
                        const nextDurationText = context.upcoming.duration_hours === 24 ? '24-hour fast' : `${context.upcoming.duration_hours}-hour fast`;
                        supplementaryLine = `Next scheduled fast: ${formatRelativeDate(nextStart)} ‚Ä¢ ${nextDurationText}`;
                    }
                    hintText = 'Start whenever you\'re ready to follow the plan.';
                    break;
                }
                case 'future': {
                    const timeUntil = formatTimeUntil(start, now);
                    primaryLine = `${descriptor} ‚Ä¢ ${durationText} ‚Ä¢ in ${timeUntil}`;
                    break;
                }
                default:
                    break;
            }

            if (detailsEl) {
                detailsEl.textContent = primaryLine;
            }

            if (titleEl) {
                titleText = titleText || 'üóìÔ∏è Next Scheduled Fast';
                titleEl.textContent = titleText;
            }

            if (hintEl) {
                if (supplementaryLine) {
                    hintEl.textContent = `${hintText} ${supplementaryLine}`.trim();
                } else {
                    hintEl.textContent = hintText;
                }
            }
        }

        function handleScheduleWindowData(data, { allowAutoApply = false } = {}) {
            latestScheduleWindow = data || null;

            if (!data) {
                scheduledFastContext = null;
                isScheduledFastActionable = false;
                canStartScheduledFast = false;
                updateScheduledFastCard(null);
                updateStartButtonText();
                return null;
            }

            if (typeof window.FastingForecastFastDurationResolver === 'function') {
                const resolverPayload = {
                    upcoming: data.upcoming || null,
                    recent: data.recent || null,
                    defaultDurationHours: data.defaultDurationHours || 24,
                    now: new Date()
                };

                const resolverWasMissing = !durationResolver;

                if (!durationResolver) {
                    durationResolver = new window.FastingForecastFastDurationResolver(resolverPayload);
                } else {
                    durationResolver.updateData(resolverPayload);
                }

                const suggestedBaseline = typeof durationResolver.peekRecommendedDuration === 'function'
                    ? durationResolver.peekRecommendedDuration()
                    : (typeof durationResolver.getDefaultDuration === 'function'
                        ? durationResolver.getDefaultDuration()
                        : 24);

                const parsedBaseline = Number(suggestedBaseline);
                if (Number.isFinite(parsedBaseline) && parsedBaseline > 0) {
                    autoSelectedDuration = Math.max(1, Math.round(parsedBaseline));
                }

                const shouldAutoApply = (allowAutoApply || resolverWasMissing) && !hasUserAdjustedDuration;

                if (shouldAutoApply) {
                    applyAutoDuration(durationResolver.getRecommendedDuration());
                }
            }

            scheduledFastContext = deriveScheduledFastContext(data);
            isScheduledFastActionable = scheduledFastContext.status === 'actionable_upcoming' || scheduledFastContext.status === 'actionable_recent';
            canStartScheduledFast = scheduledFastContext.status === 'actionable_upcoming';

            updateScheduledFastCard(data);
            updateStartButtonText();

            return data;
        }

        function applyAutoDuration(duration) {
            const parsedDuration = Number(duration);
            if (!Number.isFinite(parsedDuration) || parsedDuration <= 0) {
                return;
            }

            const normalized = Math.max(1, Math.round(parsedDuration));
            autoSelectedDuration = normalized;

            if (!isRunning) {
                fastDuration = normalized;
            }

            if (selectedDuration === normalized && !hasUserAdjustedDuration) {
                // Ensure UI reflects the default selection without triggering manual mode
                selectDuration(normalized, { userInitiated: false });
                return;
            }

            selectDuration(normalized, { userInitiated: false });
        }

        // Load and display the next scheduled fast
        async function loadNextScheduledFast() {
            try {
                const upcomingScheduleResponse = await fetch(`/api/schedule/upcoming?sessionId=${globalSessionId}&tz=${encodeURIComponent(clientTimeZone)}`);
                if (upcomingScheduleResponse.ok) {
                    handleScheduleWindowData(await upcomingScheduleResponse.json(), { allowAutoApply: !durationResolver });
                } else {
                    console.error('Failed to fetch upcoming schedule');
                    // Set fallback text if API fails
                    document.getElementById('scheduledFastDetails').textContent = 'Schedule unavailable';
                }
            } catch (error) {
                console.error('Error loading next scheduled fast:', error);
                // Set fallback text if there's an error
                document.getElementById('scheduledFastDetails').textContent = 'Schedule unavailable';
            }
        }
        
        // Check user schedule status and show appropriate state
        async function checkUserScheduleStatus(sessionId) {
            try {
                const userScheduleResponse = await fetch(`/api/schedule?sessionId=${sessionId}`);
                if (userScheduleResponse.ok) {
                    const userScheduleData = await userScheduleResponse.json();
                    if (userScheduleData.schedule && userScheduleData.blocks && userScheduleData.blocks.length > 0) {
                        // User has a schedule with fasting blocks
                        await showScheduledFastState();
                    } else if (userScheduleData.draft) {
                        // Draft available - show onboarding draft state
                        showNewUserWelcome();
                        if (timerOnboardingController) {
                            timerOnboardingController.applyDraft(userScheduleData.draft);
                        }
                    } else {
                        // User has no schedule or draft - encourage setup
                        showScheduleSetupState();
                    }
                } else {
                    // API error - default to schedule setup
                    showScheduleSetupState();
                }
            } catch (error) {
                console.error('Error checking schedule status:', error);
                showScheduleSetupState();
            }
        }

        // Handle schedule setup button click
        function showScheduleSetup() {
            window.location.href = '/schedule';
        }
        
        // Confetti Animation
        function createConfetti() {
            const canvas = document.getElementById('confettiCanvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const confettiPieces = [];
            const colors = ['#fcd34d', '#fb923c', '#ec4899', '#28a745', '#20c997'];
            
            // Create confetti pieces
            for (let i = 0; i < 150; i++) {
                confettiPieces.push({
                    x: Math.random() * canvas.width,
                    y: -10,
                    dx: (Math.random() - 0.5) * 4,
                    dy: Math.random() * 3 + 2,
                    rotation: Math.random() * 360,
                    rotationSpeed: (Math.random() - 0.5) * 10,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    shape: Math.random() > 0.5 ? 'rectangle' : 'circle',
                    size: Math.random() * 6 + 4
                });
            }
            
            let animationFrame;
            
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                for (let j = confettiPieces.length - 1; j >= 0; j--) {
                    const piece = confettiPieces[j];
                    
                    // Update position
                    piece.x += piece.dx;
                    piece.y += piece.dy;
                    piece.rotation += piece.rotationSpeed;
                    
                    // Add gravity
                    piece.dy += 0.15;
                    
                    // Apply air resistance
                    piece.dx *= 0.99;
                    
                    // Draw piece
                    ctx.save();
                    ctx.translate(piece.x, piece.y);
                    ctx.rotate(piece.rotation * Math.PI / 180);
                    ctx.fillStyle = piece.color;
                    
                    if (piece.shape === 'circle') {
                        ctx.beginPath();
                        ctx.arc(0, 0, piece.size / 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.fillRect(-piece.size / 2, -piece.size / 2, piece.size, piece.size);
                    }
                    
                    ctx.restore();
                    
                    // Remove pieces that fall off screen
                    if (piece.y > canvas.height + 20) {
                        confettiPieces.splice(j, 1);
                    }
                }
                
                if (confettiPieces.length > 0) {
                    animationFrame = requestAnimationFrame(animate);
                } else {
                    // Hide canvas when animation is done
                    setTimeout(() => {
                        canvas.style.display = 'none';
                    }, 1000);
                }
            }
            
            canvas.style.display = 'block';
            animate();
        }
        
        // Calculate estimated calories burned during fasting
        function calculateCaloriesBurned(durationHours) {
            // Placeholder user profile (will be replaced with actual user data after onboarding)
            const userProfile = {
                weight: 160, // lbs
                bodyFatPercent: 25,
                activityLevel: 'sedentary' // sedentary, lightly_active, moderately_active, very_active, extremely_active
            };
            
            // Calculate lean body mass
            const weightKg = userProfile.weight * 0.453592;
            const leanBodyMassKg = weightKg * (1 - userProfile.bodyFatPercent / 100);
            
            // Calculate BMR using Katch-McArdle formula (based on lean body mass)
            const bmr = 370 + (21.6 * leanBodyMassKg);
            
            // Activity multipliers
            const activityMultipliers = {
                sedentary: 1.2,
                lightly_active: 1.375,
                moderately_active: 1.55,
                very_active: 1.725,
                extremely_active: 1.9
            };
            
            // Calculate TDEE
            const tdee = bmr * activityMultipliers[userProfile.activityLevel];
            const hourlyTdee = tdee / 24;
            
            // Apply fasting metabolic adjustments based on duration
            let totalCalories = 0;
            
            for (let hour = 0; hour < Math.ceil(durationHours); hour++) {
                let metabolicRate;
                
                if (hour < 12) {
                    metabolicRate = 0.95; // Minimal metabolic adaptation
                } else if (hour < 24) {
                    metabolicRate = 0.90; // Slight metabolic adaptation
                } else if (hour < 48) {
                    metabolicRate = 0.85; // Moderate metabolic adaptation
                } else {
                    metabolicRate = 0.80; // Significant metabolic adaptation
                }
                
                // For partial hours, calculate proportionally
                const hourFraction = hour < Math.floor(durationHours) ? 1 : (durationHours % 1);
                totalCalories += hourlyTdee * metabolicRate * hourFraction;
            }
            
            // Format with commas for readability
            return Math.round(totalCalories).toLocaleString();
        }
        
        // Get achieved milestones based on elapsed time
        function getAchievedMilestones(elapsedHours) {
            return milestones.filter(milestone => elapsedHours >= milestone.hours);
        }
        
        // Show fast completion state
        function showFastCompletion() {
            // Calculate final stats
            const finalElapsedHours = elapsedTime / (1000 * 60 * 60);
            const achievedMilestones = getAchievedMilestones(finalElapsedHours);
            
            // Update completion display
            const completionHours = Math.floor(finalElapsedHours);
            const completionMinutes = Math.floor((finalElapsedHours % 1) * 60);
            document.getElementById('completionDuration').textContent = 
                `${completionHours}:${String(completionMinutes).padStart(2, '0')}`;
            
            // Update calories
            document.getElementById('completionCalories').textContent = 
                `~${calculateCaloriesBurned(finalElapsedHours)}`;
            
            // Update milestones
            const milestonesContainer = document.getElementById('completionMilestones');
            milestonesContainer.innerHTML = '';
            
            if (achievedMilestones.length === 0) {
                milestonesContainer.innerHTML = '<p style="color: #666; font-style: italic;">Complete your first 12-hour milestone to see achievements here!</p>';
            } else {
                achievedMilestones.forEach(milestone => {
                    const milestoneEl = document.createElement('div');
                    milestoneEl.className = 'milestone-item';
                    milestoneEl.innerHTML = `
                        <div class="icon">${milestone.icon}</div>
                        <div class="info">
                            <div class="title">${milestone.title}</div>
                            <div class="time">Achieved at ${milestone.hours}h</div>
                        </div>
                    `;
                    milestonesContainer.appendChild(milestoneEl);
                });
            }
            
            // Hide active state and show completion
            document.getElementById('activeFastState').style.display = 'none';
            document.getElementById('completionState').style.display = 'block';
            
            // Trigger confetti animation
            createConfetti();
        }
        
        // Handle refeed notes CTA (placeholder)
        function openRefeedNotes() {
            // Placeholder - would open a modal or navigate to notes page
            alert('Refeed notes feature coming soon! üìù\n\nThis would allow you to log:\n‚Ä¢ How you feel post-fast\n‚Ä¢ Refeeding meal details\n‚Ä¢ Energy levels\n‚Ä¢ Any insights or observations');
        }
        
        // Start a new fast from completion screen
        function startNewFast() {
            // Hide completion state
            document.getElementById('completionState').style.display = 'none';
            
            // Reset all timer state
            if (isRunning) {
                clearInterval(timerInterval);
                isRunning = false;
            }
            
            // Clear milestone markers
            document.getElementById('milestoneMarkers').innerHTML = '';
            
            // Reset milestone tracking
            lastReachedMilestone = null;
            
            // Reset start time selection
            selectedStartTime = null;
            document.querySelector('input[name="startTime"][value="now"]').checked = true;
            document.getElementById('timeInputGroup').style.display = 'none';
            document.getElementById('startTimeInput').value = '';
            
            // Hide adjustment controls
            cancelStartTimeAdjustment();
            
            // Hide duration selector
            document.getElementById('durationSelector').style.display = 'none';
            
            // Show pre-fast state
            document.getElementById('preFastState').style.display = 'block';
            
            elapsedTime = 0;
            fastStartTime = null;
            
            // Update button text
            updateStartButtonText();
        }
        
        // Note: Timer now continues indefinitely until user manually ends the fast
        // The checkFastCompletion() function has been removed to allow fasting beyond planned duration
        
        // Initialize
        loadStats(); // Async call - no need to await in initialization
        
        // Bottom Navigation Functionality
        function updateActiveNavItem() {
            const currentPath = window.location.pathname;
            const navItems = document.querySelectorAll('.nav-item');
            
            navItems.forEach(item => {
                item.classList.remove('active');
                const href = item.getAttribute('href');
                
                // Set active state based on current path
                if (href === currentPath || (href === '/timer' && (currentPath === '/timer' || currentPath === '/timer.html'))) {
                    item.classList.add('active');
                }
            });
        }
        
        // Update navigation on page load
        document.addEventListener('DOMContentLoaded', () => {
            updateActiveNavItem();
            
            // Add click handlers for navigation items
            const clickNavItems = document.querySelectorAll('.nav-item');
            clickNavItems.forEach(item => {
                item.addEventListener('click', (e) => {
                    const clickHref = item.getAttribute('href');
                    
                    // For now, prevent default navigation for pages that don't exist
                    if (clickHref !== '/dashboard' && clickHref !== '/timer' && clickHref !== '/schedule' && clickHref !== '/settings') {
                        e.preventDefault();
                        
                        // Show a temporary message for unimplemented pages
                        const pageName = item.querySelector('.nav-label').textContent;
                        alert(`${pageName} page coming soon!`);
                    }
                });
            });
            
            // Add resize handler to recalculate milestone positions
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    // Only recalculate if milestones are currently visible
                    if (document.getElementById('milestoneMarkers').children.length > 0) {
                        createMilestoneMarkers();
                    }
                }, 150); // Debounce resize events
            });
            
            // Add scroll event listener for sticky button
            let scrollTimeout;
            window.addEventListener('scroll', () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    updateStickyButtonVisibility();
                }, 10); // Debounce scroll events
            });
        });
        
        // Update active nav item when navigating (for SPA-style navigation in the future)
        window.addEventListener('popstate', updateActiveNavItem);
        
        // Database integration functions
        async function createFastEntry() {
            try {
                // Get session ID to link fast to user profile
                const createSessionId = window.getSessionId();
                console.log('Creating fast entry with sessionId:', createSessionId);
                
                const fastData = {
                    start_time: fastStartTime.toISOString(),
                    notes: null,
                    weight: null,
                    is_manual: false,
                    sessionId: createSessionId
                };
                
                console.log('Sending fast data:', fastData);
                
                const createResponse = await fetch('/api/fasts/start', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(fastData)
                });
                
                if (createResponse.ok) {
                    const createdFast = await createResponse.json();
                    currentFastId = createdFast.id;
                    console.log('Fast entry created:', createdFast);
                } else {
                    console.error('Failed to create fast entry');
                }
            } catch (error) {
                console.error('Error creating fast entry:', error);
            }
        }
        
        async function endFastEntry() {
            if (!currentFastId) return;

            try {
                const endTimeISO = new Date().toISOString();
                const sessionId = window.getSessionId();

                if (!sessionId) {
                    console.error('No session ID available for ending fast');
                    return;
                }

                const endResponse = await fetch(`/api/fasts/${currentFastId}/end`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        end_time: endTimeISO,
                        sessionId: sessionId
                    })
                });
                
                if (endResponse.ok) {
                    const completedFast = await endResponse.json();
                    console.log('Fast entry completed:', completedFast);
                    currentFastId = null;

                    // Update stats display after completing a fast
                    loadStats();
                } else {
                    const errorData = await endResponse.json().catch(() => ({}));
                    console.error('Failed to end fast entry:', endResponse.status, errorData);
                    console.error('Response status:', endResponse.status);
                    console.error('Error details:', errorData);
                }
            } catch (error) {
                console.error('Error ending fast entry:', error);
            }
        }

        // Reset to initial state - clean slate
        function resetToInitialState() {
            console.log('üö® resetToInitialState() called - currentFastId:', currentFastId, 'isRunning:', isRunning);

            // Don't reset if we have an active fast that was just restored
            if (currentFastId && isRunning) {
                console.log('üö® BLOCKED resetToInitialState() - active fast detected, ignoring reset request');
                return;
            }

            // Stop any running timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // Reset all timer variables
            isRunning = false;
            fastStartTime = null;
            elapsedTime = 0;
            currentFastId = null;

            // Reset start time selection
            selectedStartTime = null;
            if (document.querySelector('input[name="startTime"][value="now"]')) {
                document.querySelector('input[name="startTime"][value="now"]').checked = true;
            }

            // Show pre-fast state, hide active fast state
            document.getElementById('preFastState').style.display = 'block';
            document.getElementById('activeFastState').style.display = 'none';
            document.querySelector('.welcome-message').style.display = 'block';

            // Clear any adjustment controls
            const adjustmentRow = document.getElementById('startTimeAdjustment');
            if (adjustmentRow) {
                adjustmentRow.style.display = 'none';
            }

            console.log('Reset to initial state - ready for fresh fast start');
        }

        // Check for active fast on page load
        async function checkForActiveFast() {
            try {
                console.log('üîç checkForActiveFast started');

                // First check if we have timer state in localStorage
                const savedTimerState = localStorage.getItem('fastingForecast_timerState');
                console.log('üîç localStorage timer state:', savedTimerState ? 'exists' : 'empty');

                // Get session ID for user-specific active fast check
                const checkSessionId = window.getSessionId();
                console.log('üîç Session ID for fast check:', checkSessionId);
                if (!checkSessionId) {
                    console.log('No session ID found, cannot check for active fast');
                    // Clear any stale localStorage if no session
                    if (savedTimerState) {
                        console.log('Clearing stale timer state - no session ID');
                        localStorage.removeItem('fastingForecast_timerState');
                    }
                    return;
                }

                console.log('üîç Making API call to /api/fasts/active');
                const activeResponse = await fetch(`/api/fasts/active?sessionId=${checkSessionId}`);
                console.log('üîç API response status:', activeResponse.status);

                if (activeResponse.ok) {
                    const activeFast = await activeResponse.json();
                    console.log('üîç Active fast from API:', activeFast);

                    if (activeFast && savedTimerState) {
                        // Restore timer state if both database and localStorage indicate active fast
                        console.log('üîÑ Taking restoreTimerState path - activeFast.id:', activeFast.id);
                        await restoreTimerState(savedTimerState, activeFast);
                    } else if (!activeFast && savedTimerState) {
                        // Clear stale localStorage if database shows no active fast
                        console.log('Clearing stale timer state from localStorage - no active fast in database');
                        localStorage.removeItem('fastingForecast_timerState');
                        // Ensure we're in the correct initial state
                        resetToInitialState();
                    } else if (activeFast && !savedTimerState) {
                        try {
                            // Database has active fast but no localStorage state - restore the timer
                            console.log('üöÄ Found active fast but no localStorage state, restoring timer');

                            // Immediately hide pre-fast state to prevent placeholder display
                            document.getElementById('preFastState').style.display = 'none';
                            console.log('üöÄ activeFast.id:', activeFast.id);
                            console.log('üöÄ activeFast.start_time:', activeFast.start_time);

                        if (!activeFast.id || !activeFast.start_time) {
                            console.error('üöÄ Invalid active fast object - missing id or start_time');
                            return;
                        }

                        console.log('üöÄ Setting currentFastId to:', activeFast.id);
                        // Avoid scoping issues by using a local variable
                        const activeFastId = activeFast.id;

                        // Set global currentFastId immediately to avoid race conditions
                        currentFastId = activeFastId;

                        // Ensure proper date parsing from database UTC timestamp
                        const dbStartTime = activeFast.start_time;
                        console.log('üöÄ Raw database start_time:', dbStartTime);
                        fastStartTime = new Date(dbStartTime);
                        console.log('üöÄ Parsed fastStartTime:', fastStartTime, 'isValid:', !isNaN(fastStartTime.getTime()));

                        if (isNaN(fastStartTime.getTime())) {
                            console.error('üöÄ Invalid start time could not be parsed');
                            return;
                        }

                        isRunning = true;
                        window.isRunning = true; // Expose to window for testing
                        elapsedTime = Date.now() - fastStartTime.getTime();
                        console.log('üöÄ Calculated elapsed time:', Math.round(elapsedTime / 1000), 'seconds');

                        console.log('üöÄ About to show active fast UI and start timer...');

                        try {
                            // Show active fast UI
                            console.log('üöÄ Setting UI display states...');
                            document.getElementById('preFastState').style.display = 'none';
                            document.getElementById('activeFastState').style.display = 'block';
                            document.querySelector('.welcome-message').style.display = 'none';
                            console.log('üöÄ UI display states set successfully');
                        } catch (uiError) {
                            console.error('üöÄ Error setting UI states:', uiError);
                        }

                        try {
                            // Set up timer display
                            console.log('üöÄ Calling updateTimerDisplay...');
                            updateTimerDisplay();
                            console.log('üöÄ updateTimerDisplay completed');
                        } catch (timerDisplayError) {
                            console.error('üöÄ Error in updateTimerDisplay:', timerDisplayError);
                        }

                        try {
                            // Update start and end time display immediately
                            console.log('üöÄ Calling updateTimeDisplay from timer setup...');
                            updateTimeDisplay();
                            console.log('üöÄ updateTimeDisplay completed from timer setup');
                        } catch (timeDisplayError) {
                            console.error('üöÄ Error in updateTimeDisplay:', timeDisplayError);
                        }

                        try {

                            // Start the timer interval
                            console.log('üöÄ Starting timer interval from session restoration - fastStartTime:', fastStartTime);
                            timerInterval = setInterval(() => {
                                const newElapsedTime = Date.now() - fastStartTime.getTime();
                                elapsedTime = newElapsedTime;
                                updateTimerDisplay();
                            }, 1000);
                            console.log('üöÄ Timer interval started successfully');

                            // Update start and end time display
                            console.log('üöÄ Calling updateTimeDisplay...');
                            updateTimeDisplay();
                            console.log('üöÄ updateTimeDisplay completed');

                            // Save timer state to localStorage to prevent future inconsistencies
                            const restoredTimerState = {
                                fastStartTime: fastStartTime.toISOString(),
                                fastDuration: 24, // Default duration
                                isRunning: true,
                                currentFastId: currentFastId
                            };
                            localStorage.setItem('fastingForecast_timerState', JSON.stringify(restoredTimerState));
                            console.log('üöÄ Timer state saved to localStorage during restoration');

                        } catch (timerError) {
                            console.error('üöÄ Error setting up timer:', timerError);
                        }

                        // Initialize phase banner
                        if (!phaseBanner) {
                            initializePhaseBanner();
                        }

                        // Initialize cards and notifications
                        if (!cardRotationManager) {
                            await initializeCardRotationManager();
                        }
                        await showContextualCards();

                            if (globalNotificationManager) {
                                await globalNotificationManager.startNotificationsForFast(fastStartTime, 24); // Default 24h duration
                            }

                            // Set the global currentFastId only after everything else is successful
                            console.log('üöÄ Setting global currentFastId at the end');
                            currentFastId = activeFastId;
                            window.currentFastId = activeFastId; // Expose to window for testing
                        } catch (restoreError) {
                            console.error('üöÄ Error during timer restoration:', restoreError);
                            console.error('üöÄ Error stack:', restoreError.stack);
                        }
                    }
                }
            } catch (error) {
                console.error('Error checking for active fast:', error);
            }
        }
        
        // Restore timer state from localStorage
        async function restoreTimerState(savedStateString, activeFast) {
            try {
                console.log('üîÑ restoreTimerState called - activeFast.id:', activeFast.id);
                const savedState = JSON.parse(savedStateString);
                console.log('üîÑ savedState.currentFastId:', savedState.currentFastId);

                // Validate saved state matches database
                if (savedState.currentFastId !== activeFast.id) {
                    console.log('üö® Saved timer state does not match active fast, clearing localStorage');
                    console.log('   savedState.currentFastId:', savedState.currentFastId);
                    console.log('   activeFast.id:', activeFast.id);
                    localStorage.removeItem('fastingForecast_timerState');
                    return;
                }

                // Restore timer variables
                console.log('üîÑ Setting currentFastId to:', savedState.currentFastId);
                currentFastId = savedState.currentFastId;
                console.log('üîÑ Global currentFastId is now:', currentFastId);

                // Ensure proper date parsing from localStorage
                const localStorageStartTime = savedState.fastStartTime;
                console.log('Raw localStorage fastStartTime:', localStorageStartTime);
                fastStartTime = new Date(localStorageStartTime);
                console.log('Parsed fastStartTime:', fastStartTime, 'isValid:', !isNaN(fastStartTime.getTime()));

                fastDuration = savedState.fastDuration;
                isRunning = true;

                // Calculate current elapsed time
                elapsedTime = Date.now() - fastStartTime.getTime();
                console.log('Calculated elapsed time:', Math.round(elapsedTime / 1000), 'seconds');
                
                console.log('Restoring timer state:', {
                    fastStartTime: fastStartTime,
                    fastDuration: fastDuration,
                    elapsedTime: Math.round(elapsedTime / 1000) + 's'
                });
                
                // Update UI to show active fast state
                document.getElementById('preFastState').style.display = 'none';
                document.getElementById('activeFastState').style.display = 'block';
                document.querySelector('.welcome-message').style.display = 'none';
                
                // Create milestone markers
                createMilestoneMarkers();

                // Initialize phase banner
                if (!phaseBanner) {
                    initializePhaseBanner();
                }

                // Initialize and show contextual cards
                if (!cardRotationManager) {
                    await initializeCardRotationManager();
                }
                await showContextualCards();

                // Resume global notifications for the fast
                if (globalNotificationManager) {
                    await globalNotificationManager.startNotificationsForFast(fastStartTime, fastDuration);
                }

                // Set start and end times
                updateTimeDisplay();
                
                // Update timer display immediately
                updateTimerDisplay();
                
                // Update milestone states based on elapsed time
                updateMilestoneStates();
                
                // Start the timer interval
                console.log('Starting timer interval from localStorage restoration - fastStartTime:', fastStartTime);
                timerInterval = setInterval(() => {
                    const newElapsedTime = Date.now() - fastStartTime.getTime();
                    elapsedTime = newElapsedTime;
                    updateTimerDisplay();
                }, 1000);
                
            } catch (error) {
                console.error('üö® Error restoring timer state:', error);
                console.error('üö® Error stack:', error.stack);

                // Only clear localStorage for serious errors, not minor display issues
                if (error.message && (error.message.includes('Invalid') || error.message.includes('parse'))) {
                    console.error('üö® Clearing localStorage due to data corruption');
                    localStorage.removeItem('fastingForecast_timerState');
                } else {
                    console.warn('üö® Keeping localStorage despite error - attempting recovery');
                    // Try to fall back to direct restoration
                    try {
                        console.log('üîÑ Attempting fallback restoration...');
                        document.getElementById('preFastState').style.display = 'none';
                        document.getElementById('activeFastState').style.display = 'block';
                        document.querySelector('.welcome-message').style.display = 'none';
                    } catch (fallbackError) {
                        console.error('üö® Fallback also failed:', fallbackError);
                    }
                }
            }
        }
        
        // Check for upcoming scheduled fast
        async function checkForUpcomingFast() {
            try {
                // Check for upcoming fast
                const upcomingResponse = await fetch(`/api/schedule/upcoming?sessionId=${globalSessionId}&tz=${encodeURIComponent(clientTimeZone)}`);
                if (upcomingResponse.ok) {
                    handleScheduleWindowData(await upcomingResponse.json(), { allowAutoApply: true });
                } else if (upcomingResponse.status === 404) {
                    // If user profile not found (database was reset), clear localStorage and redirect to onboarding
                    const upcomingErrorData = await upcomingResponse.json();
                    if (upcomingErrorData.error && upcomingErrorData.error.includes('User profile not found')) {
                        console.log('User profile missing after server restart - redirecting to onboarding');
                        localStorage.removeItem('fastingForecast_sessionId');
                        localStorage.removeItem('fastingForecast_profileSaved');
                        window.location.href = '/forecaster';
                        return;
                    }
                }
                
                // Check if user has a schedule and hide setup prompt if they do
                const scheduleResponse = await fetch(`/api/schedule?sessionId=${globalSessionId}&tz=${encodeURIComponent(clientTimeZone)}`);
                if (scheduleResponse.ok) {
                    const scheduleData = await scheduleResponse.json();
                    const scheduleSetupElement = document.getElementById('scheduleSetupState');
                    if (scheduleSetupElement) {
                        if (scheduleData.schedule) {
                            // User has a schedule, hide the setup prompt
                            scheduleSetupElement.style.display = 'none';
                        } else {
                            // User doesn't have a schedule, show the setup prompt
                            scheduleSetupElement.style.display = 'block';
                        }
                    }
                } else if (scheduleResponse.status === 404) {
                    // If user profile not found (database was reset), clear localStorage and redirect to onboarding
                    const scheduleErrorData = await scheduleResponse.json();
                    if (scheduleErrorData.error && scheduleErrorData.error.includes('User profile not found')) {
                        console.log('User profile missing after server restart - redirecting to onboarding');
                        localStorage.removeItem('fastingForecast_sessionId');
                        localStorage.removeItem('fastingForecast_profileSaved');
                        window.location.href = '/forecaster';
                        return;
                    }
                }
            } catch (error) {
                console.error('Error checking for upcoming fast:', error);
            }
        }

        function shouldUseScheduledStart() {
            return canStartScheduledFast &&
                scheduledFastContext?.actionableInstance?.id &&
                selectedDuration === autoSelectedDuration &&
                !selectedStartTime;
        }

        async function startScheduledFast(instanceId) {
            try {
                const response = await fetch('/api/schedule/start-early', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: globalSessionId,
                        upcomingId: instanceId,
                        timeZone: clientTimeZone
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    alert('Failed to start scheduled fast: ' + (errorData.error || 'Unknown error'));
                    return false;
                }

                const result = await response.json();

                currentFastId = result.fastId || null;
                fastStartTime = result.startTime ? new Date(result.startTime) : new Date();
                fastDuration = Number(result.duration) > 0 ? Math.round(result.duration) : autoSelectedDuration;
                selectedDuration = fastDuration;
                autoSelectedDuration = fastDuration;
                hasUserAdjustedDuration = false;
                durationResolver?.clearManualSelection?.();

                document.getElementById('durationSelector').style.display = 'none';
                document.getElementById('preFastState').style.display = 'none';
                document.getElementById('activeFastState').style.display = 'block';
                document.querySelector('.welcome-message').style.display = 'none';

                isRunning = true;
                selectedStartTime = null;
                elapsedTime = 0;

                createMilestoneMarkers();

                if (!phaseBanner) {
                    initializePhaseBanner();
                }

                if (!cardRotationManager) {
                    await initializeCardRotationManager();
                }
                await showContextualCards();

                if (globalNotificationManager) {
                    await globalNotificationManager.startNotificationsForFast(fastStartTime, fastDuration);
                }

                const timerState = {
                    isRunning: true,
                    fastStartTime: fastStartTime.toISOString(),
                    fastDuration: fastDuration,
                    currentFastId: currentFastId
                };
                localStorage.setItem('fastingForecast_timerState', JSON.stringify(timerState));

                updateStartButtonText();
                updateTimeDisplay();
                updateTimerDisplay();

                if (timerInterval) {
                    clearInterval(timerInterval);
                }
                timerInterval = setInterval(() => {
                    elapsedTime = Date.now() - fastStartTime.getTime();
                    updateTimerDisplay();
                }, 1000);

                await loadStats();
                await checkForUpcomingFast();

                return true;
            } catch (error) {
                console.error('Error starting scheduled fast:', error);
                alert('Failed to start scheduled fast. Please try again.');
                return false;
            }
        }
        
        
        // Check for active fast and upcoming fast when page loads - moved to session ready callback
        // checkForActiveFast();
        // checkForUpcomingFast();
    </script>
    
    <!-- Navigation Placeholder -->
    <div id="navigation-placeholder"></div>

    <!-- Navigation Utility -->
    <script src="/js/utils/navigation.js"></script>

    <!-- Session Management - Scripts moved to HEAD -->
    <script>
        // Global variables
        let lastReachedMilestone = null; // Track milestone states globally
        let cardRotationManager = null; // Card rotation manager instance
        let hungerCoach = null; // Legacy hunger coach instance
        let currentFastId = null; // Current active fast ID
        let phaseBanner = null; // Phase banner instance
        let tipRotationInterval = null; // Tip rotation interval
        const TIP_ROTATION_INTERVAL = 12000; // 12 seconds for tip rotation

        // Fasting phases with descriptions
        const phases = {
            0: {
                title: "Getting Started",
                description: "Your body is beginning to use stored glucose and transitioning away from constant feeding."
            },
            4: {
                title: "Early Adaptation",
                description: "Blood sugar stabilizing. Initial hunger pangs are normal as your body adjusts."
            },
            8: {
                title: "Metabolic Shift",
                description: "Your body is starting to switch from glucose to fat burning. Energy may fluctuate."
            },
            12: {
                title: "Fat Burning Mode",
                description: "Ketone production increasing. You may start feeling more focused and energized."
            },
            16: {
                title: "Deep Ketosis",
                description: "Significant ketone production. Mental clarity improving, hunger often subsides."
            },
            24: {
                title: "Optimal Fat Burning",
                description: "Peak fat oxidation and ketone production. Maximum metabolic benefits activated."
            },
            36: {
                title: "Advanced Ketosis",
                description: "Deep therapeutic ketosis. Enhanced autophagy and cellular repair processes."
            },
            48: {
                title: "Extended Benefits",
                description: "Maximum autophagy, growth hormone elevation, and metabolic optimization."
            }
        };

        let timerOnboardingController = null;
        try {
            const draftApi = new window.FastingForecastDraftScheduleApi();
            timerOnboardingController = new window.FastingForecastTimerOnboardingController({
                api: draftApi,
                navigation: {
                    goToSchedule: () => {
                        window.location.href = '/schedule.html';
                    }
                }
            });
            window.timerOnboardingController = timerOnboardingController;
        } catch (error) {
            console.error('Failed to initialize TimerOnboardingController:', error);
        }

        // Initialize session management first
        let pageGuard;
        try {
            pageGuard = new window.FastingForecastPageSessionGuard();
            window.pageGuard = pageGuard; // Make it available globally for getSessionId()
        } catch (error) {
            console.error('‚ùå Failed to create PageSessionGuard:', error);
            // Set a fallback so tests can see that we tried
            window.pageGuard = {
                isReady: false,
                error: error.message,
                waitForReady: () => Promise.reject(error)
            };
            pageGuard = window.pageGuard;
        }

        // Wait for session to be ready before continuing with page logic
        if (window.pageGuard && !window.pageGuard.error) {
            window.pageGuard.waitForReady().then(() => {
            console.log('‚úì Session manager ready for timer.html');

            // Test session ID
            const sessionId = window.getSessionId();
            console.log('‚úì Current session ID:', sessionId);

            // Now that session is ready, check for active fast and upcoming fast
            console.log('‚úì Starting timer initialization with session ready');

            checkForActiveFast().then(() => {
                console.log('‚úì checkForActiveFast completed');
            }).catch(error => {
                console.error('‚úó checkForActiveFast failed:', error);
            });

            checkForUpcomingFast().then(() => {
                console.log('‚úì checkForUpcomingFast completed');
            }).catch(error => {
                console.error('‚úó checkForUpcomingFast failed:', error);
            });

            // Initialize user state after session is ready
            initializeUserState().then(() => {
                console.log('‚úì initializeUserState completed');

                if (timerOnboardingController) {
                    timerOnboardingController.init(sessionId);
                }
            }).catch(error => {
                console.error('‚úó initializeUserState failed:', error);
            });
            }).catch(error => {
                console.error('‚úó Session manager failed to initialize:', error);
            });
        } else {
            console.error('‚ùå PageSessionGuard not available, skipping session initialization');
        }
    </script>
</body>
</html>
